
uFocus2B.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  00001094  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000ffc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000088  00800100  00800100  00001090  2**0
                  ALLOC
  3 .eeprom       00000004  00810000  00810000  00001090  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         00002bb0  00000000  00000000  00001094  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      00001665  00000000  00000000  00003c44  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .comment      00000011  00000000  00000000  000052a9  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 00000100  00000000  00000000  000052c0  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   00000a8c  00000000  00000000  000053c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00000642  00000000  00000000  00005e4c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00000349  00000000  00000000  0000648e  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000209  00000000  00000000  000067d7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	2a c0       	rjmp	.+84     	; 0x56 <__ctors_end>
   2:	39 c0       	rjmp	.+114    	; 0x76 <__bad_interrupt>
   4:	38 c0       	rjmp	.+112    	; 0x76 <__bad_interrupt>
   6:	37 c0       	rjmp	.+110    	; 0x76 <__bad_interrupt>
   8:	36 c0       	rjmp	.+108    	; 0x76 <__bad_interrupt>
   a:	35 c0       	rjmp	.+106    	; 0x76 <__bad_interrupt>
   c:	34 c0       	rjmp	.+104    	; 0x76 <__bad_interrupt>
   e:	14 c2       	rjmp	.+1064   	; 0x438 <__vector_7>
  10:	32 c0       	rjmp	.+100    	; 0x76 <__bad_interrupt>
  12:	31 c0       	rjmp	.+98     	; 0x76 <__bad_interrupt>
  14:	30 c0       	rjmp	.+96     	; 0x76 <__bad_interrupt>
  16:	09 c3       	rjmp	.+1554   	; 0x62a <__vector_11>
  18:	2e c0       	rjmp	.+92     	; 0x76 <__bad_interrupt>
  1a:	2d c0       	rjmp	.+90     	; 0x76 <__bad_interrupt>
  1c:	2c c0       	rjmp	.+88     	; 0x76 <__bad_interrupt>
  1e:	2b c0       	rjmp	.+86     	; 0x76 <__bad_interrupt>
  20:	2a c0       	rjmp	.+84     	; 0x76 <__bad_interrupt>
  22:	29 c0       	rjmp	.+82     	; 0x76 <__bad_interrupt>
  24:	14 c4       	rjmp	.+2088   	; 0x84e <__vector_18>
  26:	4e c4       	rjmp	.+2204   	; 0x8c4 <__vector_19>
  28:	26 c0       	rjmp	.+76     	; 0x76 <__bad_interrupt>
  2a:	cc c1       	rjmp	.+920    	; 0x3c4 <__vector_21>
  2c:	24 c0       	rjmp	.+72     	; 0x76 <__bad_interrupt>
  2e:	23 c0       	rjmp	.+70     	; 0x76 <__bad_interrupt>
  30:	22 c0       	rjmp	.+68     	; 0x76 <__bad_interrupt>
  32:	21 c0       	rjmp	.+66     	; 0x76 <__bad_interrupt>
  34:	c0 c0       	rjmp	.+384    	; 0x1b6 <ProcessRx+0xd8>
  36:	cf c0       	rjmp	.+414    	; 0x1d6 <ProcessRx+0xf8>
  38:	db c0       	rjmp	.+438    	; 0x1f0 <ProcessRx+0x112>
  3a:	eb c0       	rjmp	.+470    	; 0x212 <ProcessRx+0x134>
  3c:	04 c1       	rjmp	.+520    	; 0x246 <ProcessRx+0x168>
  3e:	29 c1       	rjmp	.+594    	; 0x292 <ProcessRx+0x1b4>
  40:	81 c1       	rjmp	.+770    	; 0x344 <__stack+0x45>
  42:	91 c1       	rjmp	.+802    	; 0x366 <__stack+0x67>
  44:	99 c1       	rjmp	.+818    	; 0x378 <__stack+0x79>
  46:	1a c7       	rjmp	.+3636   	; 0xe7c <Step+0x10>
  48:	1c c7       	rjmp	.+3640   	; 0xe82 <Step+0x16>
  4a:	1e c7       	rjmp	.+3644   	; 0xe88 <Step+0x1c>
  4c:	23 c7       	rjmp	.+3654   	; 0xe94 <Step+0x28>
  4e:	27 c7       	rjmp	.+3662   	; 0xe9e <Step+0x32>
  50:	2d c7       	rjmp	.+3674   	; 0xeac <Step+0x40>
  52:	2f c7       	rjmp	.+3678   	; 0xeb2 <Step+0x46>
  54:	34 c7       	rjmp	.+3688   	; 0xebe <Step+0x52>

00000056 <__ctors_end>:
  56:	11 24       	eor	r1, r1
  58:	1f be       	out	0x3f, r1	; 63
  5a:	cf ef       	ldi	r28, 0xFF	; 255
  5c:	d2 e0       	ldi	r29, 0x02	; 2
  5e:	de bf       	out	0x3e, r29	; 62
  60:	cd bf       	out	0x3d, r28	; 61

00000062 <__do_clear_bss>:
  62:	11 e0       	ldi	r17, 0x01	; 1
  64:	a0 e0       	ldi	r26, 0x00	; 0
  66:	b1 e0       	ldi	r27, 0x01	; 1
  68:	01 c0       	rjmp	.+2      	; 0x6c <.do_clear_bss_start>

0000006a <.do_clear_bss_loop>:
  6a:	1d 92       	st	X+, r1

0000006c <.do_clear_bss_start>:
  6c:	a8 38       	cpi	r26, 0x88	; 136
  6e:	b1 07       	cpc	r27, r17
  70:	e1 f7       	brne	.-8      	; 0x6a <.do_clear_bss_loop>
  72:	6a d5       	rcall	.+2772   	; 0xb48 <main>
  74:	c1 c7       	rjmp	.+3970   	; 0xff8 <_exit>

00000076 <__bad_interrupt>:
  76:	c4 cf       	rjmp	.-120    	; 0x0 <__vectors>

00000078 <AddToTx>:

/* Add a command to the TX buffer */
unsigned char AddToTx(unsigned char cmd, unsigned char* data, unsigned char datalen)
{
	/* Disable interrupts for this next bit */
	cli();
  78:	f8 94       	cli

	/* Create a local copy of TxBufEnd */
	unsigned char lTxBufEnd = TxBufEnd;
  7a:	90 91 59 01 	lds	r25, 0x0159

	/* Add the packet to the TX buffer */
	for(unsigned char i = 0; i <= datalen; i++)
  7e:	50 e0       	ldi	r21, 0x00	; 0
  80:	29 2f       	mov	r18, r25
  82:	30 e0       	ldi	r19, 0x00	; 0
	{
		/* Add a byte */
		if(i)
  84:	55 23       	and	r21, r21
  86:	41 f0       	breq	.+16     	; 0x98 <AddToTx+0x20>
		{
			TxBuf[lTxBufEnd] = *data;
  88:	db 01       	movw	r26, r22
  8a:	ed 91       	ld	r30, X+
  8c:	bd 01       	movw	r22, r26
  8e:	d9 01       	movw	r26, r18
  90:	ac 5e       	subi	r26, 0xEC	; 236
  92:	be 4f       	sbci	r27, 0xFE	; 254
  94:	ec 93       	st	X, r30
  96:	04 c0       	rjmp	.+8      	; 0xa0 <AddToTx+0x28>
			data ++;
		}
		else TxBuf[lTxBufEnd] = cmd;
  98:	f9 01       	movw	r30, r18
  9a:	ec 5e       	subi	r30, 0xEC	; 236
  9c:	fe 4f       	sbci	r31, 0xFE	; 254
  9e:	80 83       	st	Z, r24

		if(i < datalen)
  a0:	54 17       	cp	r21, r20
  a2:	58 f4       	brcc	.+22     	; 0xba <AddToTx+0x42>
		{
			/* Increment the local buffer end pointer */
			lTxBufEnd ++;
  a4:	9f 5f       	subi	r25, 0xFF	; 255
			if(lTxBufEnd == TxBufSize)
  a6:	90 32       	cpi	r25, 0x20	; 32
  a8:	09 f4       	brne	.+2      	; 0xac <AddToTx+0x34>
			{
				lTxBufEnd = 0;
  aa:	90 e0       	ldi	r25, 0x00	; 0
			}

			/* If we've run out of buffer, return an error and forget we added anything */
			if(lTxBufEnd == TxBufStart)
  ac:	20 91 11 01 	lds	r18, 0x0111
  b0:	92 13       	cpse	r25, r18
  b2:	03 c0       	rjmp	.+6      	; 0xba <AddToTx+0x42>
			{
				sei();
  b4:	78 94       	sei
				return(1);
  b6:	81 e0       	ldi	r24, 0x01	; 1
  b8:	08 95       	ret

	/* Create a local copy of TxBufEnd */
	unsigned char lTxBufEnd = TxBufEnd;

	/* Add the packet to the TX buffer */
	for(unsigned char i = 0; i <= datalen; i++)
  ba:	5f 5f       	subi	r21, 0xFF	; 255
  bc:	45 17       	cp	r20, r21
  be:	00 f7       	brcc	.-64     	; 0x80 <AddToTx+0x8>
			}
		}
	}

	/* Update the buffer end pointer */
	TxBufEnd = lTxBufEnd;
  c0:	90 93 59 01 	sts	0x0159, r25

	/* Enable UDRIE and interrupts */
	UCSR0B |= 1<<UDRIE0;
  c4:	80 91 c1 00 	lds	r24, 0x00C1
  c8:	80 62       	ori	r24, 0x20	; 32
  ca:	80 93 c1 00 	sts	0x00C1, r24
	sei();
  ce:	78 94       	sei

	/* Flash the green LED */
	LEDStatus |= 1<<LEDGreen;
  d0:	80 91 84 01 	lds	r24, 0x0184
  d4:	82 60       	ori	r24, 0x02	; 2
  d6:	80 93 84 01 	sts	0x0184, r24

	/* Return OK */
	return(0);
  da:	80 e0       	ldi	r24, 0x00	; 0
}
  dc:	08 95       	ret

000000de <ProcessRx>:
 * 13 -
 * 14 -
 * 15 -
 */
void ProcessRx(void)
{
  de:	cf 92       	push	r12
  e0:	df 92       	push	r13
  e2:	ef 92       	push	r14
  e4:	cf 93       	push	r28
  e6:	df 93       	push	r29
  e8:	00 d0       	rcall	.+0      	; 0xea <ProcessRx+0xc>
  ea:	cd b7       	in	r28, 0x3d	; 61
  ec:	de b7       	in	r29, 0x3e	; 62
	/* Turn off interrupts */
	cli();
  ee:	f8 94       	cli

	/* Pull the first byte out of the buffer */
	unsigned char RxByte = RxBuf[RxBufStart];
  f0:	e0 91 7e 01 	lds	r30, 0x017E
  f4:	f0 e0       	ldi	r31, 0x00	; 0
  f6:	e6 5a       	subi	r30, 0xA6	; 166
  f8:	fe 4f       	sbci	r31, 0xFE	; 254
  fa:	80 81       	ld	r24, Z

	/* If we're not at the end of received data yet, increment our buffer start */
	if(RxBufStart != RxBufEnd) RxBufStart ++;
  fc:	20 91 7e 01 	lds	r18, 0x017E
 100:	90 91 3e 01 	lds	r25, 0x013E
 104:	29 17       	cp	r18, r25
 106:	29 f0       	breq	.+10     	; 0x112 <ProcessRx+0x34>
 108:	90 91 7e 01 	lds	r25, 0x017E
 10c:	9f 5f       	subi	r25, 0xFF	; 255
 10e:	90 93 7e 01 	sts	0x017E, r25
	if(RxBufStart == RxBufSize) RxBufStart = 0;
 112:	90 91 7e 01 	lds	r25, 0x017E
 116:	90 32       	cpi	r25, 0x20	; 32
 118:	19 f4       	brne	.+6      	; 0x120 <ProcessRx+0x42>
 11a:	10 92 7e 01 	sts	0x017E, r1
 11e:	09 c0       	rjmp	.+18     	; 0x132 <ProcessRx+0x54>

	/* If we are at the end of the buffer data, turn off the new data flag */
	else
	{
		SerStatus &= ~(1<<SerNewRx);
 120:	90 91 0e 01 	lds	r25, 0x010E
 124:	9e 7f       	andi	r25, 0xFE	; 254
 126:	90 93 0e 01 	sts	0x010E, r25
		RxBufStart = 0;
 12a:	10 92 7e 01 	sts	0x017E, r1
		RxBufEnd = 0;
 12e:	10 92 3e 01 	sts	0x013E, r1
	}
	/* Interrupts back on */
	sei();
 132:	78 94       	sei

	/* Is there a command in progress? */
	if(CmdStatus & (1<<CmdInProg))
 134:	90 91 3d 01 	lds	r25, 0x013D
 138:	97 ff       	sbrs	r25, 7
 13a:	0a c0       	rjmp	.+20     	; 0x150 <ProcessRx+0x72>
	{
		/* Increment the command data counter */
		CmdDataRec ++;
 13c:	e0 91 3c 01 	lds	r30, 0x013C
 140:	ef 5f       	subi	r30, 0xFF	; 255
 142:	e0 93 3c 01 	sts	0x013C, r30
		/* Save the byte in our command buffer */
		CmdData[CmdDataRec-1] = RxByte;
 146:	f0 e0       	ldi	r31, 0x00	; 0
 148:	e8 5b       	subi	r30, 0xB8	; 184
 14a:	fe 4f       	sbci	r31, 0xFE	; 254
 14c:	80 83       	st	Z, r24
 14e:	0b c0       	rjmp	.+22     	; 0x166 <ProcessRx+0x88>
		sei();
	}
	else
	{
		/* Pull our command data length out of the command byte */
		CmdDataLen = (RxByte & 0xF0)>>4;
 150:	98 2f       	mov	r25, r24
 152:	92 95       	swap	r25
 154:	9f 70       	andi	r25, 0x0F	; 15
 156:	90 93 10 01 	sts	0x0110, r25
		/* Pull the command value out of the byte and indicate that there's a command in progress */
		CmdStatus = (RxByte & 0x0F) | (1<<CmdInProg);
 15a:	8f 70       	andi	r24, 0x0F	; 15
 15c:	80 68       	ori	r24, 0x80	; 128
 15e:	80 93 3d 01 	sts	0x013D, r24
		/* Zero out the command data counter */
		CmdDataRec = 0;
 162:	10 92 3c 01 	sts	0x013C, r1
		/* Reset the command timeout */
		cli();
 166:	f8 94       	cli
		CmdTimer = Tmr1ms;
 168:	80 91 82 01 	lds	r24, 0x0182
 16c:	90 91 83 01 	lds	r25, 0x0183
 170:	90 93 01 01 	sts	0x0101, r25
 174:	80 93 00 01 	sts	0x0100, r24
		sei();
 178:	78 94       	sei
	}

	/* Have we received all of the bytes for this command yet? */
	if(CmdDataRec == CmdDataLen)
 17a:	90 91 3c 01 	lds	r25, 0x013C
 17e:	80 91 10 01 	lds	r24, 0x0110
 182:	98 13       	cpse	r25, r24
 184:	12 c1       	rjmp	.+548    	; 0x3aa <__stack+0xab>
	{
		/* Save a local Position */
		cli();
 186:	f8 94       	cli
		signed int Pos = (signed int)Position;
 188:	c0 90 02 01 	lds	r12, 0x0102
 18c:	d0 90 03 01 	lds	r13, 0x0103
 190:	e0 90 04 01 	lds	r14, 0x0104
 194:	da 82       	std	Y+2, r13	; 0x02
 196:	c9 82       	std	Y+1, r12	; 0x01

		/* Sort out what command we're processing */
		switch(CmdStatus & 0x0F)
 198:	80 91 3d 01 	lds	r24, 0x013D
 19c:	e8 2f       	mov	r30, r24
 19e:	ef 70       	andi	r30, 0x0F	; 15
 1a0:	8e 2f       	mov	r24, r30
 1a2:	90 e0       	ldi	r25, 0x00	; 0
 1a4:	fc 01       	movw	r30, r24
 1a6:	31 97       	sbiw	r30, 0x01	; 1
 1a8:	e9 30       	cpi	r30, 0x09	; 9
 1aa:	f1 05       	cpc	r31, r1
 1ac:	08 f0       	brcs	.+2      	; 0x1b0 <ProcessRx+0xd2>
 1ae:	f2 c0       	rjmp	.+484    	; 0x394 <__stack+0x95>
 1b0:	e6 5e       	subi	r30, 0xE6	; 230
 1b2:	ff 4f       	sbci	r31, 0xFF	; 255
 1b4:	09 94       	ijmp
		{
		/* Return Position */
		case 1:
			CmdData[0] = *(char *)&Pos;
 1b6:	89 81       	ldd	r24, Y+1	; 0x01
 1b8:	80 93 49 01 	sts	0x0149, r24
			CmdData[1] = *((char *)&Pos + 1);
 1bc:	8a 81       	ldd	r24, Y+2	; 0x02
 1be:	80 93 4a 01 	sts	0x014A, r24
			CmdData[2] = TCCR1B & 0b00000101;
 1c2:	80 91 81 00 	lds	r24, 0x0081
 1c6:	85 70       	andi	r24, 0x05	; 5
 1c8:	80 93 4b 01 	sts	0x014B, r24
			AddToTx(0x31, &CmdData[0], 3);
 1cc:	43 e0       	ldi	r20, 0x03	; 3
 1ce:	69 e4       	ldi	r22, 0x49	; 73
 1d0:	71 e0       	ldi	r23, 0x01	; 1
 1d2:	81 e3       	ldi	r24, 0x31	; 49
 1d4:	e3 c0       	rjmp	.+454    	; 0x39c <__stack+0x9d>
			break;
		/* Set Position */
		case 2:
			*(char *)&SetPosition = CmdData[0];
 1d6:	80 91 49 01 	lds	r24, 0x0149
 1da:	80 93 47 01 	sts	0x0147, r24
			*((char *)&SetPosition + 1) = CmdData[1];
 1de:	80 91 4a 01 	lds	r24, 0x014A
 1e2:	80 93 48 01 	sts	0x0148, r24
			AddToTx(0x22, &CmdData[0], 2);
 1e6:	42 e0       	ldi	r20, 0x02	; 2
 1e8:	69 e4       	ldi	r22, 0x49	; 73
 1ea:	71 e0       	ldi	r23, 0x01	; 1
 1ec:	82 e2       	ldi	r24, 0x22	; 34
 1ee:	d6 c0       	rjmp	.+428    	; 0x39c <__stack+0x9d>
			break;
		/* Halt and Return Position */
		case 3:
			SetPosition = Pos;
 1f0:	d0 92 48 01 	sts	0x0148, r13
 1f4:	c0 92 47 01 	sts	0x0147, r12
			CmdData[0] = *(char *)&SetPosition;
 1f8:	80 91 47 01 	lds	r24, 0x0147
 1fc:	80 93 49 01 	sts	0x0149, r24
			CmdData[1] = *((char *)&SetPosition + 1);
 200:	80 91 48 01 	lds	r24, 0x0148
 204:	80 93 4a 01 	sts	0x014A, r24
			AddToTx(0x23, &CmdData[0], 2);
 208:	42 e0       	ldi	r20, 0x02	; 2
 20a:	69 e4       	ldi	r22, 0x49	; 73
 20c:	71 e0       	ldi	r23, 0x01	; 1
 20e:	83 e2       	ldi	r24, 0x23	; 35
 210:	c5 c0       	rjmp	.+394    	; 0x39c <__stack+0x9d>
			break;
		/* Enable temperature compensation */
		case 4:
			AddToTx(0x24, &CmdData[0], 2);
 212:	42 e0       	ldi	r20, 0x02	; 2
 214:	69 e4       	ldi	r22, 0x49	; 73
 216:	71 e0       	ldi	r23, 0x01	; 1
 218:	84 e2       	ldi	r24, 0x24	; 36
 21a:	2e df       	rcall	.-420    	; 0x78 <AddToTx>
			BaseTemp = Temperature;
 21c:	80 91 09 01 	lds	r24, 0x0109
 220:	90 91 0a 01 	lds	r25, 0x010A
 224:	90 93 35 01 	sts	0x0135, r25
 228:	80 93 34 01 	sts	0x0134, r24
			BasePosition = Pos;
 22c:	d0 92 41 01 	sts	0x0141, r13
 230:	c0 92 40 01 	sts	0x0140, r12
			*(char *)&TempCoeff = CmdData[0];
 234:	80 91 49 01 	lds	r24, 0x0149
 238:	80 93 05 01 	sts	0x0105, r24
			*((char *)&TempCoeff + 1) = CmdData[1];
 23c:	80 91 4a 01 	lds	r24, 0x014A
 240:	80 93 06 01 	sts	0x0106, r24
			break;
 244:	ac c0       	rjmp	.+344    	; 0x39e <__stack+0x9f>
		/* Return current temperature, temp comp status, temp coefficient, motor velocity, position, and idle off setting */
		case 5:
			CmdData[0] = *(char *)&Temperature;
 246:	80 91 09 01 	lds	r24, 0x0109
 24a:	80 93 49 01 	sts	0x0149, r24
			CmdData[1] = *((char *)&Temperature + 1);
 24e:	80 91 0a 01 	lds	r24, 0x010A
 252:	80 93 4a 01 	sts	0x014A, r24
			CmdData[2] = *(char *)&TempCoeff;
 256:	80 91 05 01 	lds	r24, 0x0105
 25a:	80 93 4b 01 	sts	0x014B, r24
			CmdData[3] = *((char *)&TempCoeff + 1);
 25e:	80 91 06 01 	lds	r24, 0x0106
 262:	80 93 4c 01 	sts	0x014C, r24
			CmdData[4] = MotStatus & (1<<IdleOff);
 266:	80 91 12 01 	lds	r24, 0x0112
 26a:	81 70       	andi	r24, 0x01	; 1
 26c:	80 93 4d 01 	sts	0x014D, r24
			CmdData[5] = MaxAccel;
 270:	80 91 0b 01 	lds	r24, 0x010B
 274:	80 93 4e 01 	sts	0x014E, r24
			CmdData[6] = *(char *)&MaxVel;
 278:	80 91 7b 01 	lds	r24, 0x017B
 27c:	80 93 4f 01 	sts	0x014F, r24
			CmdData[7] = *((char *)&MaxVel + 1);
 280:	80 91 7c 01 	lds	r24, 0x017C
 284:	80 93 50 01 	sts	0x0150, r24
			AddToTx(0x85, &CmdData[0], 8);
 288:	48 e0       	ldi	r20, 0x08	; 8
 28a:	69 e4       	ldi	r22, 0x49	; 73
 28c:	71 e0       	ldi	r23, 0x01	; 1
 28e:	85 e8       	ldi	r24, 0x85	; 133
 290:	85 c0       	rjmp	.+266    	; 0x39c <__stack+0x9d>
			break;
		/* Set motor velocity, acceleration, and idle off settings*/
		case 6:
			if(CmdData[3]) MotStatus |= 1<<IdleOff;
 292:	80 91 4c 01 	lds	r24, 0x014C
 296:	88 23       	and	r24, r24
 298:	21 f0       	breq	.+8      	; 0x2a2 <ProcessRx+0x1c4>
 29a:	80 91 12 01 	lds	r24, 0x0112
 29e:	81 60       	ori	r24, 0x01	; 1
 2a0:	03 c0       	rjmp	.+6      	; 0x2a8 <ProcessRx+0x1ca>
			else MotStatus &= ~(1<<IdleOff);
 2a2:	80 91 12 01 	lds	r24, 0x0112
 2a6:	8e 7f       	andi	r24, 0xFE	; 254
 2a8:	80 93 12 01 	sts	0x0112, r24

			// Make sure accel is non-zero
			MaxAccel = CmdData[2];
 2ac:	80 91 4b 01 	lds	r24, 0x014B
 2b0:	80 93 0b 01 	sts	0x010B, r24
			if(MaxAccel > 127) MaxAccel = 127;
 2b4:	80 91 0b 01 	lds	r24, 0x010B
			if(MaxAccel == 0) MaxAccel = 1;
 2b8:	80 91 0b 01 	lds	r24, 0x010B
 2bc:	81 11       	cpse	r24, r1
 2be:	03 c0       	rjmp	.+6      	; 0x2c6 <ProcessRx+0x1e8>
 2c0:	81 e0       	ldi	r24, 0x01	; 1
 2c2:	80 93 0b 01 	sts	0x010B, r24
			SafeStopVel = CalcSafeStopVel(MaxAccel);
 2c6:	80 91 0b 01 	lds	r24, 0x010B
 2ca:	31 d3       	rcall	.+1634   	; 0x92e <CalcSafeStopVel>
 2cc:	70 93 39 01 	sts	0x0139, r23
 2d0:	60 93 38 01 	sts	0x0138, r22

			*(char *)&MaxVel = CmdData[0];
 2d4:	80 91 49 01 	lds	r24, 0x0149
 2d8:	80 93 7b 01 	sts	0x017B, r24
			*((char *)&MaxVel + 1) = CmdData[1];
 2dc:	80 91 4a 01 	lds	r24, 0x014A
 2e0:	80 93 7c 01 	sts	0x017C, r24
			//Limit max velocity to 1-2000
			if(MaxVel > 2000) MaxVel = 2000;
 2e4:	80 91 7b 01 	lds	r24, 0x017B
 2e8:	90 91 7c 01 	lds	r25, 0x017C
 2ec:	81 3d       	cpi	r24, 0xD1	; 209
 2ee:	97 40       	sbci	r25, 0x07	; 7
 2f0:	30 f0       	brcs	.+12     	; 0x2fe <ProcessRx+0x220>
 2f2:	80 ed       	ldi	r24, 0xD0	; 208
 2f4:	97 e0       	ldi	r25, 0x07	; 7
 2f6:	90 93 7c 01 	sts	0x017C, r25
 2fa:	80 93 7b 01 	sts	0x017B, r24
			if(MaxVel == 0) MaxVel = 1;
 2fe:	80 91 7b 01 	lds	r24, 0x017B
 302:	90 91 7c 01 	lds	r25, 0x017C
 306:	89 2b       	or	r24, r25
 308:	31 f4       	brne	.+12     	; 0x316 <__stack+0x17>
 30a:	81 e0       	ldi	r24, 0x01	; 1
 30c:	90 e0       	ldi	r25, 0x00	; 0
 30e:	90 93 7c 01 	sts	0x017C, r25
 312:	80 93 7b 01 	sts	0x017B, r24
			CalcMaxVel100();
 316:	3b d3       	rcall	.+1654   	; 0x98e <CalcMaxVel100>

			eeprom_update_word(&saveMaxVel, MaxVel);
 318:	60 91 7b 01 	lds	r22, 0x017B
 31c:	70 91 7c 01 	lds	r23, 0x017C
 320:	82 e0       	ldi	r24, 0x02	; 2
 322:	90 e0       	ldi	r25, 0x00	; 0
 324:	56 d6       	rcall	.+3244   	; 0xfd2 <__eeupd_word_m48>
			eeprom_update_byte(&saveAccel, MaxAccel);
 326:	60 91 0b 01 	lds	r22, 0x010B
 32a:	81 e0       	ldi	r24, 0x01	; 1
 32c:	90 e0       	ldi	r25, 0x00	; 0
 32e:	3f d6       	rcall	.+3198   	; 0xfae <__eeupd_byte_m48>
			eeprom_update_byte(&saveIdle, CmdData[3]);
 330:	60 91 4c 01 	lds	r22, 0x014C
 334:	80 e0       	ldi	r24, 0x00	; 0
 336:	90 e0       	ldi	r25, 0x00	; 0
 338:	3a d6       	rcall	.+3188   	; 0xfae <__eeupd_byte_m48>
			AddToTx(0x46, &CmdData[0], 4);
 33a:	44 e0       	ldi	r20, 0x04	; 4
 33c:	69 e4       	ldi	r22, 0x49	; 73
 33e:	71 e0       	ldi	r23, 0x01	; 1
 340:	86 e4       	ldi	r24, 0x46	; 70
 342:	2c c0       	rjmp	.+88     	; 0x39c <__stack+0x9d>
			break;
		/* Zero the current position and set point */
		case 7:
			cli();
 344:	f8 94       	cli
			Position = 0;
 346:	10 92 02 01 	sts	0x0102, r1
 34a:	10 92 03 01 	sts	0x0103, r1
 34e:	10 92 04 01 	sts	0x0104, r1
			SetPosition = 0;
 352:	10 92 48 01 	sts	0x0148, r1
 356:	10 92 47 01 	sts	0x0147, r1
			sei();
 35a:	78 94       	sei
			AddToTx(0x07, 0, 0);
 35c:	40 e0       	ldi	r20, 0x00	; 0
 35e:	60 e0       	ldi	r22, 0x00	; 0
 360:	70 e0       	ldi	r23, 0x00	; 0
 362:	87 e0       	ldi	r24, 0x07	; 7
 364:	1b c0       	rjmp	.+54     	; 0x39c <__stack+0x9d>
			break;
		/* Return the home switch state */
		case 8:
			CmdData[0] = PINB & 0x01;
 366:	83 b1       	in	r24, 0x03	; 3
 368:	81 70       	andi	r24, 0x01	; 1
 36a:	80 93 49 01 	sts	0x0149, r24
			AddToTx(0x18, &CmdData[0], 1);
 36e:	41 e0       	ldi	r20, 0x01	; 1
 370:	69 e4       	ldi	r22, 0x49	; 73
 372:	71 e0       	ldi	r23, 0x01	; 1
 374:	88 e1       	ldi	r24, 0x18	; 24
 376:	12 c0       	rjmp	.+36     	; 0x39c <__stack+0x9d>
			break;
		/* Set a temporary velocity limit*/
		case 9:
			*(char *)&MaxVel = CmdData[0];
 378:	80 91 49 01 	lds	r24, 0x0149
 37c:	80 93 7b 01 	sts	0x017B, r24
			*((char *)&MaxVel + 1) = CmdData[1];
 380:	80 91 4a 01 	lds	r24, 0x014A
 384:	80 93 7c 01 	sts	0x017C, r24
			CalcMaxVel100();
 388:	02 d3       	rcall	.+1540   	; 0x98e <CalcMaxVel100>

			AddToTx(0x29, &CmdData[0], 2);
 38a:	42 e0       	ldi	r20, 0x02	; 2
 38c:	69 e4       	ldi	r22, 0x49	; 73
 38e:	71 e0       	ldi	r23, 0x01	; 1
 390:	89 e2       	ldi	r24, 0x29	; 41
 392:	04 c0       	rjmp	.+8      	; 0x39c <__stack+0x9d>
			break;
		/* Return unknown command */
		default:
			AddToTx(0x0F, 0, 0);
 394:	40 e0       	ldi	r20, 0x00	; 0
 396:	60 e0       	ldi	r22, 0x00	; 0
 398:	70 e0       	ldi	r23, 0x00	; 0
 39a:	8f e0       	ldi	r24, 0x0F	; 15
 39c:	6d de       	rcall	.-806    	; 0x78 <AddToTx>
			break;
		}

		sei();
 39e:	78 94       	sei

		/* Indicate that we're done with this command */
		CmdStatus &= ~(1<<CmdInProg);
 3a0:	80 91 3d 01 	lds	r24, 0x013D
 3a4:	8f 77       	andi	r24, 0x7F	; 127
 3a6:	80 93 3d 01 	sts	0x013D, r24
	}

	/* Flash the red LED */
	LEDStatus |= 1<<LEDRed;
 3aa:	80 91 84 01 	lds	r24, 0x0184
 3ae:	81 60       	ori	r24, 0x01	; 1
 3b0:	80 93 84 01 	sts	0x0184, r24
}
 3b4:	0f 90       	pop	r0
 3b6:	0f 90       	pop	r0
 3b8:	df 91       	pop	r29
 3ba:	cf 91       	pop	r28
 3bc:	ef 90       	pop	r14
 3be:	df 90       	pop	r13
 3c0:	cf 90       	pop	r12
 3c2:	08 95       	ret

000003c4 <__vector_21>:
#include <avr/interrupt.h>
#include <avr/pgmspace.h>

/* ADC */
ISR(ADC_vect)
{
 3c4:	1f 92       	push	r1
 3c6:	0f 92       	push	r0
 3c8:	0f b6       	in	r0, 0x3f	; 63
 3ca:	0f 92       	push	r0
 3cc:	11 24       	eor	r1, r1
 3ce:	8f 93       	push	r24
	/* Notify the main loop that we're done converting */
	ADCStatus |= 0x01;
 3d0:	80 91 7a 01 	lds	r24, 0x017A
 3d4:	81 60       	ori	r24, 0x01	; 1
 3d6:	80 93 7a 01 	sts	0x017A, r24
}
 3da:	8f 91       	pop	r24
 3dc:	0f 90       	pop	r0
 3de:	0f be       	out	0x3f, r0	; 63
 3e0:	0f 90       	pop	r0
 3e2:	1f 90       	pop	r1
 3e4:	18 95       	reti

000003e6 <StopIfSafe>:

/* Stops the motor if the velocity is below a safe level */
void StopIfSafe(__uint24 AbsVel)
{
 3e6:	9b 01       	movw	r18, r22
 3e8:	48 2f       	mov	r20, r24
	/* Is it safe to stop? */
	if(AbsVel < SafeStopVel)
 3ea:	80 91 38 01 	lds	r24, 0x0138
 3ee:	90 91 39 01 	lds	r25, 0x0139
 3f2:	a0 e0       	ldi	r26, 0x00	; 0
 3f4:	28 17       	cp	r18, r24
 3f6:	39 07       	cpc	r19, r25
 3f8:	4a 07       	cpc	r20, r26
 3fa:	e8 f4       	brcc	.+58     	; 0x436 <StopIfSafe+0x50>
	{
		/* Turn off clock to T1 */
		TCCR1B &= 0b11111000;
 3fc:	80 91 81 00 	lds	r24, 0x0081
 400:	88 7f       	andi	r24, 0xF8	; 248
 402:	80 93 81 00 	sts	0x0081, r24
		/* Set the timeout to the slowest */
		OCR1A = CalcDelay(1);
 406:	61 e0       	ldi	r22, 0x01	; 1
 408:	70 e0       	ldi	r23, 0x00	; 0
 40a:	80 e0       	ldi	r24, 0x00	; 0
 40c:	15 d5       	rcall	.+2602   	; 0xe38 <CalcDelay>
 40e:	90 93 89 00 	sts	0x0089, r25
 412:	80 93 88 00 	sts	0x0088, r24
		/* Zero out movement variables */
		TCNT1 = 0;
 416:	10 92 85 00 	sts	0x0085, r1
 41a:	10 92 84 00 	sts	0x0084, r1
		Vel = 0;
 41e:	10 92 7f 01 	sts	0x017F, r1
 422:	10 92 80 01 	sts	0x0180, r1
 426:	10 92 81 01 	sts	0x0181, r1
		Accel = 0;
 42a:	10 92 3f 01 	sts	0x013F, r1
		EndDist = 0;
 42e:	10 92 08 01 	sts	0x0108, r1
 432:	10 92 07 01 	sts	0x0107, r1
 436:	08 95       	ret

00000438 <__vector_7>:
	}
}

/* 1ms Timer */
ISR(TIMER2_COMPA_vect)
{
 438:	1f 92       	push	r1
 43a:	0f 92       	push	r0
 43c:	0f b6       	in	r0, 0x3f	; 63
 43e:	0f 92       	push	r0
 440:	11 24       	eor	r1, r1
 442:	cf 92       	push	r12
 444:	df 92       	push	r13
 446:	ef 92       	push	r14
 448:	2f 93       	push	r18
 44a:	3f 93       	push	r19
 44c:	4f 93       	push	r20
 44e:	5f 93       	push	r21
 450:	6f 93       	push	r22
 452:	7f 93       	push	r23
 454:	8f 93       	push	r24
 456:	9f 93       	push	r25
 458:	af 93       	push	r26
 45a:	bf 93       	push	r27
 45c:	ef 93       	push	r30
 45e:	ff 93       	push	r31
	/* We use the sign of Vel and lVel a lot, so precalculate them.
	 * Also precalc the absolute velocity.
	 */
	unsigned char VelSign = Vel > 0;
 460:	80 91 7f 01 	lds	r24, 0x017F
 464:	90 91 80 01 	lds	r25, 0x0180
 468:	a0 91 81 01 	lds	r26, 0x0181
 46c:	21 e0       	ldi	r18, 0x01	; 1
 46e:	18 16       	cp	r1, r24
 470:	19 06       	cpc	r1, r25
 472:	1a 06       	cpc	r1, r26
 474:	0c f0       	brlt	.+2      	; 0x478 <__vector_7+0x40>
 476:	20 e0       	ldi	r18, 0x00	; 0
	unsigned char lVelSign = lVel > 0;
 478:	80 91 42 01 	lds	r24, 0x0142
 47c:	90 91 43 01 	lds	r25, 0x0143
 480:	a0 91 44 01 	lds	r26, 0x0144
 484:	31 e0       	ldi	r19, 0x01	; 1
 486:	18 16       	cp	r1, r24
 488:	19 06       	cpc	r1, r25
 48a:	1a 06       	cpc	r1, r26
 48c:	0c f0       	brlt	.+2      	; 0x490 <__vector_7+0x58>
 48e:	30 e0       	ldi	r19, 0x00	; 0
	__uint24 AbsVel = (__uint24)labs((signed long)Vel);
 490:	80 91 7f 01 	lds	r24, 0x017F
 494:	90 91 80 01 	lds	r25, 0x0180
 498:	a0 91 81 01 	lds	r26, 0x0181
 49c:	bb 27       	eor	r27, r27
 49e:	a7 fd       	sbrc	r26, 7
 4a0:	b0 95       	com	r27
 4a2:	b7 ff       	sbrs	r27, 7
 4a4:	07 c0       	rjmp	.+14     	; 0x4b4 <__vector_7+0x7c>
 4a6:	b0 95       	com	r27
 4a8:	a0 95       	com	r26
 4aa:	90 95       	com	r25
 4ac:	81 95       	neg	r24
 4ae:	9f 4f       	sbci	r25, 0xFF	; 255
 4b0:	af 4f       	sbci	r26, 0xFF	; 255
 4b2:	bf 4f       	sbci	r27, 0xFF	; 255
 4b4:	6c 01       	movw	r12, r24
 4b6:	ea 2e       	mov	r14, r26

	/* Increment the global 1ms clock */
	Tmr1ms ++;
 4b8:	80 91 82 01 	lds	r24, 0x0182
 4bc:	90 91 83 01 	lds	r25, 0x0183
 4c0:	01 96       	adiw	r24, 0x01	; 1
 4c2:	90 93 83 01 	sts	0x0183, r25
 4c6:	80 93 82 01 	sts	0x0182, r24

	/* Remember our last velocity and update our current velocity */
	lVel = Vel;
 4ca:	80 91 7f 01 	lds	r24, 0x017F
 4ce:	90 91 80 01 	lds	r25, 0x0180
 4d2:	a0 91 81 01 	lds	r26, 0x0181
 4d6:	80 93 42 01 	sts	0x0142, r24
 4da:	90 93 43 01 	sts	0x0143, r25
 4de:	a0 93 44 01 	sts	0x0144, r26
	Vel += ((signed int)Accel) * 10;
 4e2:	40 91 3f 01 	lds	r20, 0x013F
 4e6:	80 91 7f 01 	lds	r24, 0x017F
 4ea:	90 91 80 01 	lds	r25, 0x0180
 4ee:	a0 91 81 01 	lds	r26, 0x0181
 4f2:	6a e0       	ldi	r22, 0x0A	; 10
 4f4:	46 02       	muls	r20, r22
 4f6:	a0 01       	movw	r20, r0
 4f8:	11 24       	eor	r1, r1
 4fa:	84 0f       	add	r24, r20
 4fc:	95 1f       	adc	r25, r21
 4fe:	a1 1d       	adc	r26, r1
 500:	57 fd       	sbrc	r21, 7
 502:	aa 95       	dec	r26
 504:	80 93 7f 01 	sts	0x017F, r24
 508:	90 93 80 01 	sts	0x0180, r25
 50c:	a0 93 81 01 	sts	0x0181, r26

	/* Saturate velocity to +/- MaxVel */
	if(AbsVel > MaxVel100)
 510:	80 91 85 01 	lds	r24, 0x0185
 514:	90 91 86 01 	lds	r25, 0x0186
 518:	a0 91 87 01 	lds	r26, 0x0187
 51c:	8c 15       	cp	r24, r12
 51e:	9d 05       	cpc	r25, r13
 520:	ae 05       	cpc	r26, r14
 522:	98 f4       	brcc	.+38     	; 0x54a <__vector_7+0x112>
	{
		if(VelSign) Vel = MaxVel100;
 524:	80 91 85 01 	lds	r24, 0x0185
 528:	90 91 86 01 	lds	r25, 0x0186
 52c:	a0 91 87 01 	lds	r26, 0x0187
 530:	21 11       	cpse	r18, r1
 532:	05 c0       	rjmp	.+10     	; 0x53e <__vector_7+0x106>
		else Vel = -MaxVel100;
 534:	a0 95       	com	r26
 536:	90 95       	com	r25
 538:	81 95       	neg	r24
 53a:	9f 4f       	sbci	r25, 0xFF	; 255
 53c:	af 4f       	sbci	r26, 0xFF	; 255
 53e:	80 93 7f 01 	sts	0x017F, r24
 542:	90 93 80 01 	sts	0x0180, r25
 546:	a0 93 81 01 	sts	0x0181, r26
	}

	/* If there's a zero crossing in velocity, reset our ending distance counter */
	if(lVelSign ^ VelSign) EndDist = 0;
 54a:	32 17       	cp	r19, r18
 54c:	21 f0       	breq	.+8      	; 0x556 <__vector_7+0x11e>
 54e:	10 92 08 01 	sts	0x0108, r1
 552:	10 92 07 01 	sts	0x0107, r1

	/* Are we on position and going slow enough to stop? */
	if(Position == (__int24)SetPosition)
 556:	20 91 02 01 	lds	r18, 0x0102
 55a:	30 91 03 01 	lds	r19, 0x0103
 55e:	40 91 04 01 	lds	r20, 0x0104
 562:	80 91 47 01 	lds	r24, 0x0147
 566:	90 91 48 01 	lds	r25, 0x0148
 56a:	aa 27       	eor	r26, r26
 56c:	97 fd       	sbrc	r25, 7
 56e:	a0 95       	com	r26
 570:	28 17       	cp	r18, r24
 572:	39 07       	cpc	r19, r25
 574:	4a 07       	cpc	r20, r26
 576:	19 f4       	brne	.+6      	; 0x57e <__vector_7+0x146>
	{
		StopIfSafe(AbsVel);
 578:	8e 2d       	mov	r24, r14
 57a:	b6 01       	movw	r22, r12
 57c:	34 df       	rcall	.-408    	; 0x3e6 <StopIfSafe>
	}

	/* Is the step timer running? */
	if(TCCR1B & 0b00000101)
 57e:	80 91 81 00 	lds	r24, 0x0081
 582:	85 70       	andi	r24, 0x05	; 5
 584:	c9 f0       	breq	.+50     	; 0x5b8 <__vector_7+0x180>
	{
		/* Get what our OC timeout should be for our current velocity */
		unsigned int TempOCR1A = CalcDelay(AbsVel);
 586:	8e 2d       	mov	r24, r14
 588:	b6 01       	movw	r22, r12
 58a:	56 d4       	rcall	.+2220   	; 0xe38 <CalcDelay>

		/* Is the next timeout short enough that we should just do it now? */
		if(TempOCR1A <= TCNT1)
 58c:	20 91 84 00 	lds	r18, 0x0084
 590:	30 91 85 00 	lds	r19, 0x0085
 594:	28 17       	cp	r18, r24
 596:	39 07       	cpc	r19, r25
 598:	a0 f1       	brcs	.+104    	; 0x602 <__vector_7+0x1ca>
		{
			/* Turn off clock to T1 */
			TCCR1B &= 0b11111000;
 59a:	20 91 81 00 	lds	r18, 0x0081
 59e:	28 7f       	andi	r18, 0xF8	; 248
 5a0:	20 93 81 00 	sts	0x0081, r18
			/* Set our new timeout and set the timer so that it'll timeout immediately */
			OCR1A = TempOCR1A;
 5a4:	90 93 89 00 	sts	0x0089, r25
 5a8:	80 93 88 00 	sts	0x0088, r24
			TCNT1 = TempOCR1A - 2;
 5ac:	02 97       	sbiw	r24, 0x02	; 2
 5ae:	90 93 85 00 	sts	0x0085, r25
 5b2:	80 93 84 00 	sts	0x0084, r24
 5b6:	20 c0       	rjmp	.+64     	; 0x5f8 <__vector_7+0x1c0>
		}
	}
	else
	{
		/* Do we need to move? */
		if(Position != SetPosition)
 5b8:	20 91 02 01 	lds	r18, 0x0102
 5bc:	30 91 03 01 	lds	r19, 0x0103
 5c0:	40 91 04 01 	lds	r20, 0x0104
 5c4:	80 91 47 01 	lds	r24, 0x0147
 5c8:	90 91 48 01 	lds	r25, 0x0148
 5cc:	aa 27       	eor	r26, r26
 5ce:	97 fd       	sbrc	r25, 7
 5d0:	a0 95       	com	r26
 5d2:	28 17       	cp	r18, r24
 5d4:	39 07       	cpc	r19, r25
 5d6:	4a 07       	cpc	r20, r26
 5d8:	a1 f0       	breq	.+40     	; 0x602 <__vector_7+0x1ca>
		{
			/* Re-enable the motor and set a slow timeout */
			Step(step);
 5da:	80 91 7d 01 	lds	r24, 0x017D
 5de:	46 d4       	rcall	.+2188   	; 0xe6c <Step>
			OCR1A = CalcDelay(0);
 5e0:	60 e0       	ldi	r22, 0x00	; 0
 5e2:	70 e0       	ldi	r23, 0x00	; 0
 5e4:	80 e0       	ldi	r24, 0x00	; 0
 5e6:	28 d4       	rcall	.+2128   	; 0xe38 <CalcDelay>
 5e8:	90 93 89 00 	sts	0x0089, r25
 5ec:	80 93 88 00 	sts	0x0088, r24
			TCNT1 = 0;
 5f0:	10 92 85 00 	sts	0x0085, r1
 5f4:	10 92 84 00 	sts	0x0084, r1

			/* Enable T1 clock */
			TCCR1B |= 0b00000101;
 5f8:	80 91 81 00 	lds	r24, 0x0081
 5fc:	85 60       	ori	r24, 0x05	; 5
 5fe:	80 93 81 00 	sts	0x0081, r24
		}
	}
}
 602:	ff 91       	pop	r31
 604:	ef 91       	pop	r30
 606:	bf 91       	pop	r27
 608:	af 91       	pop	r26
 60a:	9f 91       	pop	r25
 60c:	8f 91       	pop	r24
 60e:	7f 91       	pop	r23
 610:	6f 91       	pop	r22
 612:	5f 91       	pop	r21
 614:	4f 91       	pop	r20
 616:	3f 91       	pop	r19
 618:	2f 91       	pop	r18
 61a:	ef 90       	pop	r14
 61c:	df 90       	pop	r13
 61e:	cf 90       	pop	r12
 620:	0f 90       	pop	r0
 622:	0f be       	out	0x3f, r0	; 63
 624:	0f 90       	pop	r0
 626:	1f 90       	pop	r1
 628:	18 95       	reti

0000062a <__vector_11>:

/* Step timer */
ISR(TIMER1_COMPA_vect)
{
 62a:	1f 92       	push	r1
 62c:	0f 92       	push	r0
 62e:	0f b6       	in	r0, 0x3f	; 63
 630:	0f 92       	push	r0
 632:	11 24       	eor	r1, r1
 634:	2f 92       	push	r2
 636:	3f 92       	push	r3
 638:	4f 92       	push	r4
 63a:	6f 92       	push	r6
 63c:	7f 92       	push	r7
 63e:	8f 92       	push	r8
 640:	cf 92       	push	r12
 642:	df 92       	push	r13
 644:	ef 92       	push	r14
 646:	ff 92       	push	r15
 648:	2f 93       	push	r18
 64a:	3f 93       	push	r19
 64c:	4f 93       	push	r20
 64e:	5f 93       	push	r21
 650:	6f 93       	push	r22
 652:	7f 93       	push	r23
 654:	8f 93       	push	r24
 656:	9f 93       	push	r25
 658:	af 93       	push	r26
 65a:	bf 93       	push	r27
 65c:	cf 93       	push	r28
 65e:	df 93       	push	r29
 660:	ef 93       	push	r30
 662:	ff 93       	push	r31
	/* We use the sign of Vel and Accel a lot, so precalculate them.
	 * Also precalc the absolute velocity and distance to the set position.
	 */
	unsigned char VelSign = Vel >= 0;
 664:	80 91 7f 01 	lds	r24, 0x017F
 668:	90 91 80 01 	lds	r25, 0x0180
 66c:	a0 91 81 01 	lds	r26, 0x0181
 670:	80 95       	com	r24
 672:	90 95       	com	r25
 674:	a0 95       	com	r26
 676:	88 27       	eor	r24, r24
 678:	a7 fd       	sbrc	r26, 7
 67a:	83 95       	inc	r24
 67c:	99 27       	eor	r25, r25
 67e:	aa 27       	eor	r26, r26
 680:	d8 2f       	mov	r29, r24
	unsigned char AccelSign = Accel >= 0;
 682:	c0 91 3f 01 	lds	r28, 0x013F
	__int24 Distance = (__int24)SetPosition - Position;
 686:	60 90 47 01 	lds	r6, 0x0147
 68a:	70 90 48 01 	lds	r7, 0x0148
 68e:	80 91 02 01 	lds	r24, 0x0102
 692:	90 91 03 01 	lds	r25, 0x0103
 696:	a0 91 04 01 	lds	r26, 0x0104
 69a:	88 24       	eor	r8, r8
 69c:	77 fc       	sbrc	r7, 7
 69e:	80 94       	com	r8
 6a0:	68 1a       	sub	r6, r24
 6a2:	79 0a       	sbc	r7, r25
 6a4:	8a 0a       	sbc	r8, r26
	__uint24 AbsVel = (__uint24)labs((signed long)Vel);
 6a6:	c0 90 7f 01 	lds	r12, 0x017F
 6aa:	d0 90 80 01 	lds	r13, 0x0180
 6ae:	e0 90 81 01 	lds	r14, 0x0181
 6b2:	ff 24       	eor	r15, r15
 6b4:	e7 fc       	sbrc	r14, 7
 6b6:	f0 94       	com	r15
 6b8:	f7 fe       	sbrs	r15, 7
 6ba:	08 c0       	rjmp	.+16     	; 0x6cc <__vector_11+0xa2>
 6bc:	f0 94       	com	r15
 6be:	e0 94       	com	r14
 6c0:	d0 94       	com	r13
 6c2:	c0 94       	com	r12
 6c4:	c1 1c       	adc	r12, r1
 6c6:	d1 1c       	adc	r13, r1
 6c8:	e1 1c       	adc	r14, r1
 6ca:	f1 1c       	adc	r15, r1
 6cc:	16 01       	movw	r2, r12
 6ce:	4e 2c       	mov	r4, r14

	/* Look up what our timeout value should be for our current velocity and set it */
	OCR1A = CalcDelay(AbsVel);
 6d0:	8e 2d       	mov	r24, r14
 6d2:	b6 01       	movw	r22, r12
 6d4:	b1 d3       	rcall	.+1890   	; 0xe38 <CalcDelay>
 6d6:	90 93 89 00 	sts	0x0089, r25
 6da:	80 93 88 00 	sts	0x0088, r24

	/* Are we moving? */
	if(AbsVel)
 6de:	cd 28       	or	r12, r13
 6e0:	ce 28       	or	r12, r14
 6e2:	cf 28       	or	r12, r15
 6e4:	09 f4       	brne	.+2      	; 0x6e8 <__vector_11+0xbe>
 6e6:	5d c0       	rjmp	.+186    	; 0x7a2 <__vector_11+0x178>
{
	/* We use the sign of Vel and Accel a lot, so precalculate them.
	 * Also precalc the absolute velocity and distance to the set position.
	 */
	unsigned char VelSign = Vel >= 0;
	unsigned char AccelSign = Accel >= 0;
 6e8:	8c 2f       	mov	r24, r28
 6ea:	80 95       	com	r24
 6ec:	88 1f       	adc	r24, r24
 6ee:	88 27       	eor	r24, r24
 6f0:	88 1f       	adc	r24, r24
	{
		/* Is our velocity positive? */
		if(VelSign)
		{
			/* Increment and wrap the step counter */
			step ++;
 6f2:	90 91 7d 01 	lds	r25, 0x017D

	/* Are we moving? */
	if(AbsVel)
	{
		/* Is our velocity positive? */
		if(VelSign)
 6f6:	dd 23       	and	r29, r29
 6f8:	f9 f0       	breq	.+62     	; 0x738 <__vector_11+0x10e>
		{
			/* Increment and wrap the step counter */
			step ++;
 6fa:	9f 5f       	subi	r25, 0xFF	; 255
 6fc:	90 93 7d 01 	sts	0x017D, r25
			if(step == 8) step = 0;
 700:	90 91 7d 01 	lds	r25, 0x017D
 704:	98 30       	cpi	r25, 0x08	; 8
 706:	11 f4       	brne	.+4      	; 0x70c <__vector_11+0xe2>
 708:	10 92 7d 01 	sts	0x017D, r1

			/* Increment position */
			Position ++;
 70c:	20 91 02 01 	lds	r18, 0x0102
 710:	30 91 03 01 	lds	r19, 0x0103
 714:	40 91 04 01 	lds	r20, 0x0104
 718:	2f 5f       	subi	r18, 0xFF	; 255
 71a:	3f 4f       	sbci	r19, 0xFF	; 255
 71c:	4f 4f       	sbci	r20, 0xFF	; 255
 71e:	20 93 02 01 	sts	0x0102, r18
 722:	30 93 03 01 	sts	0x0103, r19
 726:	40 93 04 01 	sts	0x0104, r20

			/* Are we accelerating? */
			if(Accel)
 72a:	90 91 3f 01 	lds	r25, 0x013F
 72e:	99 23       	and	r25, r25
 730:	e1 f1       	breq	.+120    	; 0x7aa <__vector_11+0x180>
			{
				/* If we're increasing velocity, increment the ending distance.
				 * If we're decreasing velocity, decrement the ending distance until it zeros out.
				 */
				if(AccelSign)
 732:	88 23       	and	r24, r24
 734:	01 f1       	breq	.+64     	; 0x776 <__vector_11+0x14c>
 736:	2b c0       	rjmp	.+86     	; 0x78e <__vector_11+0x164>
		}
		/* Negative velocity */
		else
		{
			/* Decrement and wrap the step counter */
			step --;
 738:	91 50       	subi	r25, 0x01	; 1
 73a:	90 93 7d 01 	sts	0x017D, r25
			if(step == 0xFF) step = 7;
 73e:	90 91 7d 01 	lds	r25, 0x017D
 742:	9f 3f       	cpi	r25, 0xFF	; 255
 744:	19 f4       	brne	.+6      	; 0x74c <__vector_11+0x122>
 746:	97 e0       	ldi	r25, 0x07	; 7
 748:	90 93 7d 01 	sts	0x017D, r25

			/* Decrement position */
			Position --;
 74c:	20 91 02 01 	lds	r18, 0x0102
 750:	30 91 03 01 	lds	r19, 0x0103
 754:	40 91 04 01 	lds	r20, 0x0104
 758:	21 50       	subi	r18, 0x01	; 1
 75a:	31 09       	sbc	r19, r1
 75c:	41 09       	sbc	r20, r1
 75e:	20 93 02 01 	sts	0x0102, r18
 762:	30 93 03 01 	sts	0x0103, r19
 766:	40 93 04 01 	sts	0x0104, r20

			/* Are we accelerating? */
			if(Accel)
 76a:	90 91 3f 01 	lds	r25, 0x013F
 76e:	99 23       	and	r25, r25
 770:	e1 f0       	breq	.+56     	; 0x7aa <__vector_11+0x180>
			{
				/* If we're decreasing velocity, increment the ending distance.
				 * If we're increasing velocity, decrement the ending distance until it zeros out.
				 */
				if(AccelSign)
 772:	88 23       	and	r24, r24
 774:	61 f0       	breq	.+24     	; 0x78e <__vector_11+0x164>
				{
					if(EndDist) EndDist --;
 776:	80 91 07 01 	lds	r24, 0x0107
 77a:	90 91 08 01 	lds	r25, 0x0108
 77e:	89 2b       	or	r24, r25
 780:	a1 f0       	breq	.+40     	; 0x7aa <__vector_11+0x180>
 782:	80 91 07 01 	lds	r24, 0x0107
 786:	90 91 08 01 	lds	r25, 0x0108
 78a:	01 97       	sbiw	r24, 0x01	; 1
 78c:	05 c0       	rjmp	.+10     	; 0x798 <__vector_11+0x16e>
				}
				else
				{
					EndDist ++;
 78e:	80 91 07 01 	lds	r24, 0x0107
 792:	90 91 08 01 	lds	r25, 0x0108
 796:	01 96       	adiw	r24, 0x01	; 1
 798:	90 93 08 01 	sts	0x0108, r25
 79c:	80 93 07 01 	sts	0x0107, r24
 7a0:	04 c0       	rjmp	.+8      	; 0x7aa <__vector_11+0x180>
	}
	/* Not moving */
	else
	{
		/* Zero out the ending distance */
		EndDist = 0;
 7a2:	10 92 08 01 	sts	0x0108, r1
 7a6:	10 92 07 01 	sts	0x0107, r1
	}

	/* Perform the actual step */
	Step(step);
 7aa:	80 91 7d 01 	lds	r24, 0x017D
 7ae:	5e d3       	rcall	.+1724   	; 0xe6c <Step>

	/* Do we need to move? */
	if(Distance)
 7b0:	61 14       	cp	r6, r1
 7b2:	71 04       	cpc	r7, r1
 7b4:	81 04       	cpc	r8, r1
 7b6:	59 f1       	breq	.+86     	; 0x80e <__vector_11+0x1e4>
	{
		/* If we're already at the maximum velocity, don't accelerate */
		if(AbsVel >= MaxVel100)
 7b8:	80 91 85 01 	lds	r24, 0x0185
 7bc:	90 91 86 01 	lds	r25, 0x0186
 7c0:	a0 91 87 01 	lds	r26, 0x0187
 7c4:	28 16       	cp	r2, r24
 7c6:	39 06       	cpc	r3, r25
 7c8:	4a 06       	cpc	r4, r26
 7ca:	18 f0       	brcs	.+6      	; 0x7d2 <__vector_11+0x1a8>
		{
			Accel = 0;
 7cc:	10 92 3f 01 	sts	0x013F, r1
 7d0:	09 c0       	rjmp	.+18     	; 0x7e4 <__vector_11+0x1ba>
		else
		{
			/* Accelerate in the direction of the distance */
			if(Distance > 0)
			{
				Accel = MaxAccel;
 7d2:	80 91 0b 01 	lds	r24, 0x010B
			Accel = 0;
		}
		else
		{
			/* Accelerate in the direction of the distance */
			if(Distance > 0)
 7d6:	16 14       	cp	r1, r6
 7d8:	17 04       	cpc	r1, r7
 7da:	18 04       	cpc	r1, r8
 7dc:	0c f0       	brlt	.+2      	; 0x7e0 <__vector_11+0x1b6>
			{
				Accel = MaxAccel;
			}
			else
			{
				Accel = -MaxAccel;
 7de:	81 95       	neg	r24
 7e0:	80 93 3f 01 	sts	0x013F, r24
			}
		}

		/* Should we be slowing down? */
		if(abs(Distance) <= EndDist)
 7e4:	20 91 07 01 	lds	r18, 0x0107
 7e8:	30 91 08 01 	lds	r19, 0x0108
 7ec:	c3 01       	movw	r24, r6
 7ee:	77 fe       	sbrs	r7, 7
 7f0:	04 c0       	rjmp	.+8      	; 0x7fa <__vector_11+0x1d0>
 7f2:	88 27       	eor	r24, r24
 7f4:	99 27       	eor	r25, r25
 7f6:	86 19       	sub	r24, r6
 7f8:	97 09       	sbc	r25, r7
 7fa:	28 17       	cp	r18, r24
 7fc:	39 07       	cpc	r19, r25
 7fe:	54 f0       	brlt	.+20     	; 0x814 <__vector_11+0x1ea>
		{
			/* Accelerate opposite our velocity */
			if(VelSign)
			{
				Accel = -MaxAccel;
 800:	80 91 0b 01 	lds	r24, 0x010B

		/* Should we be slowing down? */
		if(abs(Distance) <= EndDist)
		{
			/* Accelerate opposite our velocity */
			if(VelSign)
 804:	d1 11       	cpse	r29, r1
			{
				Accel = -MaxAccel;
 806:	81 95       	neg	r24
			}
			else
			{
				Accel = MaxAccel;
 808:	80 93 3f 01 	sts	0x013F, r24
 80c:	03 c0       	rjmp	.+6      	; 0x814 <__vector_11+0x1ea>
		}
	}
	/* Zero distance */
	else
	{
		StopIfSafe(AbsVel);
 80e:	84 2d       	mov	r24, r4
 810:	b1 01       	movw	r22, r2
 812:	e9 dd       	rcall	.-1070   	; 0x3e6 <StopIfSafe>
	}
}
 814:	ff 91       	pop	r31
 816:	ef 91       	pop	r30
 818:	df 91       	pop	r29
 81a:	cf 91       	pop	r28
 81c:	bf 91       	pop	r27
 81e:	af 91       	pop	r26
 820:	9f 91       	pop	r25
 822:	8f 91       	pop	r24
 824:	7f 91       	pop	r23
 826:	6f 91       	pop	r22
 828:	5f 91       	pop	r21
 82a:	4f 91       	pop	r20
 82c:	3f 91       	pop	r19
 82e:	2f 91       	pop	r18
 830:	ff 90       	pop	r15
 832:	ef 90       	pop	r14
 834:	df 90       	pop	r13
 836:	cf 90       	pop	r12
 838:	8f 90       	pop	r8
 83a:	7f 90       	pop	r7
 83c:	6f 90       	pop	r6
 83e:	4f 90       	pop	r4
 840:	3f 90       	pop	r3
 842:	2f 90       	pop	r2
 844:	0f 90       	pop	r0
 846:	0f be       	out	0x3f, r0	; 63
 848:	0f 90       	pop	r0
 84a:	1f 90       	pop	r1
 84c:	18 95       	reti

0000084e <__vector_18>:

ISR(USART_RX_vect)
{
 84e:	1f 92       	push	r1
 850:	0f 92       	push	r0
 852:	0f b6       	in	r0, 0x3f	; 63
 854:	0f 92       	push	r0
 856:	11 24       	eor	r1, r1
 858:	8f 93       	push	r24
 85a:	9f 93       	push	r25
 85c:	af 93       	push	r26
 85e:	bf 93       	push	r27
 860:	ef 93       	push	r30
 862:	ff 93       	push	r31
	/* Read the USART data and cache a local copy of RxBufEnd */
	unsigned char RX = UDR0;
 864:	90 91 c6 00 	lds	r25, 0x00C6
	unsigned char lRxBufEnd = RxBufEnd;
 868:	e0 91 3e 01 	lds	r30, 0x013E

	if(!(UCSR0A & 0b00011100))
 86c:	80 91 c0 00 	lds	r24, 0x00C0
 870:	8c 71       	andi	r24, 0x1C	; 28
 872:	e9 f4       	brne	.+58     	; 0x8ae <__vector_18+0x60>
	{
		/* Has the main loop handled the last byte yet? */
		if(SerStatus & 1<<SerNewRx)
 874:	80 91 0e 01 	lds	r24, 0x010E
 878:	80 ff       	sbrs	r24, 0
 87a:	10 c0       	rjmp	.+32     	; 0x89c <__vector_18+0x4e>
		{
			/* Increment the pointer */
			lRxBufEnd++;
 87c:	ef 5f       	subi	r30, 0xFF	; 255
			if(lRxBufEnd == RxBufSize)
 87e:	e0 32       	cpi	r30, 0x20	; 32
 880:	09 f4       	brne	.+2      	; 0x884 <__vector_18+0x36>
			{
				lRxBufEnd = 0;
 882:	e0 e0       	ldi	r30, 0x00	; 0

			/* If we haven't run out of buffer space, copy the received data into the buffer,
			 * update the end pointer, and notify our serial handler.  If we have, just
			 * drop the byte.
			 */
			if(lRxBufEnd != RxBufStart)
 884:	80 91 7e 01 	lds	r24, 0x017E
 888:	e8 17       	cp	r30, r24
 88a:	89 f0       	breq	.+34     	; 0x8ae <__vector_18+0x60>
			{
				RxBuf[lRxBufEnd] = RX;
 88c:	ae 2f       	mov	r26, r30
 88e:	b0 e0       	ldi	r27, 0x00	; 0
 890:	a6 5a       	subi	r26, 0xA6	; 166
 892:	be 4f       	sbci	r27, 0xFE	; 254
 894:	9c 93       	st	X, r25
				RxBufEnd = lRxBufEnd;
 896:	e0 93 3e 01 	sts	0x013E, r30
 89a:	04 c0       	rjmp	.+8      	; 0x8a4 <__vector_18+0x56>
			}
		}
		else
		{
			/* Start filling our buffer and let the main loop know there's something going on */
			RxBuf[lRxBufEnd] = RX;
 89c:	f0 e0       	ldi	r31, 0x00	; 0
 89e:	e6 5a       	subi	r30, 0xA6	; 166
 8a0:	fe 4f       	sbci	r31, 0xFE	; 254
 8a2:	90 83       	st	Z, r25
			SerStatus |= 1<<SerNewRx;
 8a4:	80 91 0e 01 	lds	r24, 0x010E
 8a8:	81 60       	ori	r24, 0x01	; 1
 8aa:	80 93 0e 01 	sts	0x010E, r24
		}
	}
}
 8ae:	ff 91       	pop	r31
 8b0:	ef 91       	pop	r30
 8b2:	bf 91       	pop	r27
 8b4:	af 91       	pop	r26
 8b6:	9f 91       	pop	r25
 8b8:	8f 91       	pop	r24
 8ba:	0f 90       	pop	r0
 8bc:	0f be       	out	0x3f, r0	; 63
 8be:	0f 90       	pop	r0
 8c0:	1f 90       	pop	r1
 8c2:	18 95       	reti

000008c4 <__vector_19>:

ISR(USART_UDRE_vect)
{
 8c4:	1f 92       	push	r1
 8c6:	0f 92       	push	r0
 8c8:	0f b6       	in	r0, 0x3f	; 63
 8ca:	0f 92       	push	r0
 8cc:	11 24       	eor	r1, r1
 8ce:	8f 93       	push	r24
 8d0:	9f 93       	push	r25
 8d2:	ef 93       	push	r30
 8d4:	ff 93       	push	r31
	/* Pull the next byte out and send it */
	UDR0 = TxBuf[TxBufStart];
 8d6:	e0 91 11 01 	lds	r30, 0x0111
 8da:	f0 e0       	ldi	r31, 0x00	; 0
 8dc:	ec 5e       	subi	r30, 0xEC	; 236
 8de:	fe 4f       	sbci	r31, 0xFE	; 254
 8e0:	80 81       	ld	r24, Z
 8e2:	80 93 c6 00 	sts	0x00C6, r24

	/* Is the buffer empty? */
	if(TxBufStart == TxBufEnd)
 8e6:	90 91 11 01 	lds	r25, 0x0111
 8ea:	80 91 59 01 	lds	r24, 0x0159
 8ee:	98 13       	cpse	r25, r24
 8f0:	0a c0       	rjmp	.+20     	; 0x906 <__vector_19+0x42>
	{
		/* Turn off the UDR0 interrupt*/
		UCSR0B &= ~(1<<UDRIE0);
 8f2:	80 91 c1 00 	lds	r24, 0x00C1
 8f6:	8f 7d       	andi	r24, 0xDF	; 223
 8f8:	80 93 c1 00 	sts	0x00C1, r24
		TxBufStart = 0;
 8fc:	10 92 11 01 	sts	0x0111, r1
		TxBufEnd = 0;
 900:	10 92 59 01 	sts	0x0159, r1
 904:	0b c0       	rjmp	.+22     	; 0x91c <__vector_19+0x58>
	}
	else
	{
		/* Increment our start pointer */
		TxBufStart ++;
 906:	80 91 11 01 	lds	r24, 0x0111
 90a:	8f 5f       	subi	r24, 0xFF	; 255
 90c:	80 93 11 01 	sts	0x0111, r24
		if(TxBufStart == TxBufSize) TxBufStart = 0;
 910:	80 91 11 01 	lds	r24, 0x0111
 914:	80 32       	cpi	r24, 0x20	; 32
 916:	11 f4       	brne	.+4      	; 0x91c <__vector_19+0x58>
 918:	10 92 11 01 	sts	0x0111, r1
	}
}
 91c:	ff 91       	pop	r31
 91e:	ef 91       	pop	r30
 920:	9f 91       	pop	r25
 922:	8f 91       	pop	r24
 924:	0f 90       	pop	r0
 926:	0f be       	out	0x3f, r0	; 63
 928:	0f 90       	pop	r0
 92a:	1f 90       	pop	r1
 92c:	18 95       	reti

0000092e <CalcSafeStopVel>:
unsigned char EEMEM saveAccel = 10;
unsigned char EEMEM saveIdle = 1;

__uint24 CalcSafeStopVel(unsigned char accel)
{
	unsigned int trueaccel = (unsigned int)accel * 100;
 92e:	94 e6       	ldi	r25, 0x64	; 100
 930:	89 9f       	mul	r24, r25
 932:	a0 01       	movw	r20, r0
 934:	11 24       	eor	r1, r1
 936:	98 e0       	ldi	r25, 0x08	; 8
unsigned int CalcDelay(__uint24 AbsVel);
void CalcMaxVel100();

static inline uint8_t friden_sqrt16(uint16_t val)
{
	uint16_t rem = 0;
 938:	20 e0       	ldi	r18, 0x00	; 0
 93a:	30 e0       	ldi	r19, 0x00	; 0
	uint16_t root = 0;
 93c:	60 e0       	ldi	r22, 0x00	; 0
 93e:	70 e0       	ldi	r23, 0x00	; 0
	uint8_t i;

	for(i = 0; i < 8; i++)
	{
		root <<= 1;
 940:	66 0f       	add	r22, r22
 942:	77 1f       	adc	r23, r23
		rem = ((rem << 2) + (val >> 14));
 944:	22 0f       	add	r18, r18
 946:	33 1f       	adc	r19, r19
 948:	22 0f       	add	r18, r18
 94a:	33 1f       	adc	r19, r19
 94c:	fa 01       	movw	r30, r20
 94e:	e4 e0       	ldi	r30, 0x04	; 4
 950:	fe 9f       	mul	r31, r30
 952:	e1 2d       	mov	r30, r1
 954:	ff 27       	eor	r31, r31
 956:	11 24       	eor	r1, r1
 958:	2e 0f       	add	r18, r30
 95a:	3f 1f       	adc	r19, r31
		val <<= 2;
 95c:	44 0f       	add	r20, r20
 95e:	55 1f       	adc	r21, r21
 960:	44 0f       	add	r20, r20
 962:	55 1f       	adc	r21, r21
		root++;
 964:	fb 01       	movw	r30, r22
 966:	31 96       	adiw	r30, 0x01	; 1
		if (root <= rem)
 968:	2e 17       	cp	r18, r30
 96a:	3f 07       	cpc	r19, r31
 96c:	20 f0       	brcs	.+8      	; 0x976 <CalcSafeStopVel+0x48>
		{
			rem -=root;
 96e:	2e 1b       	sub	r18, r30
 970:	3f 0b       	sbc	r19, r31
			root++;
 972:	6e 5f       	subi	r22, 0xFE	; 254
 974:	7f 4f       	sbci	r23, 0xFF	; 255
 976:	91 50       	subi	r25, 0x01	; 1
{
	uint16_t rem = 0;
	uint16_t root = 0;
	uint8_t i;

	for(i = 0; i < 8; i++)
 978:	19 f7       	brne	.-58     	; 0x940 <CalcSafeStopVel+0x12>
		else
		{
			root--;
		}
	}
	return (uint8_t)(root >> 1);
 97a:	76 95       	lsr	r23
 97c:	67 95       	ror	r22

	return friden_sqrt16(trueaccel) * 200;
 97e:	88 ec       	ldi	r24, 0xC8	; 200
 980:	68 9f       	mul	r22, r24
 982:	b0 01       	movw	r22, r0
 984:	11 24       	eor	r1, r1
 986:	88 27       	eor	r24, r24
 988:	77 fd       	sbrc	r23, 7
 98a:	80 95       	com	r24
}
 98c:	08 95       	ret

0000098e <CalcMaxVel100>:

void CalcMaxVel100()
{
	MaxVel100 = 100 * (__uint24)MaxVel;
 98e:	60 91 7b 01 	lds	r22, 0x017B
 992:	70 91 7c 01 	lds	r23, 0x017C
 996:	80 e0       	ldi	r24, 0x00	; 0
 998:	94 e6       	ldi	r25, 0x64	; 100
 99a:	a6 d2       	rcall	.+1356   	; 0xee8 <__mulsqipsi3>
 99c:	20 93 85 01 	sts	0x0185, r18
 9a0:	30 93 86 01 	sts	0x0186, r19
 9a4:	40 93 87 01 	sts	0x0187, r20
 9a8:	08 95       	ret

000009aa <InitSerial>:

/* Set up the serial system */
void InitSerial(void)
{
	/* Initialize TX/RX ring buffers */
	RxBufStart = 0;
 9aa:	10 92 7e 01 	sts	0x017E, r1
	RxBufEnd = 0;
 9ae:	10 92 3e 01 	sts	0x013E, r1
	TxBufStart = 0;
 9b2:	10 92 11 01 	sts	0x0111, r1
	TxBufEnd = 0;
 9b6:	10 92 59 01 	sts	0x0159, r1
	 * Configure the USART for:
	 * 115200 Baud
	 * Odd parity
	 * 8 bit data
	 */
	UBRR0 = 10;
 9ba:	8a e0       	ldi	r24, 0x0A	; 10
 9bc:	90 e0       	ldi	r25, 0x00	; 0
 9be:	90 93 c5 00 	sts	0x00C5, r25
 9c2:	80 93 c4 00 	sts	0x00C4, r24
	UCSR0A = 0;
 9c6:	10 92 c0 00 	sts	0x00C0, r1
	UCSR0C = (1<<UPM01)|(1<<UPM00)|(1<<UCSZ01)|(1<<UCSZ00);
 9ca:	86 e3       	ldi	r24, 0x36	; 54
 9cc:	80 93 c2 00 	sts	0x00C2, r24
	UCSR0B = (1<<RXEN0)|(1<<TXEN0)|(1<<RXCIE0);
 9d0:	88 e9       	ldi	r24, 0x98	; 152
 9d2:	80 93 c1 00 	sts	0x00C1, r24
 9d6:	08 95       	ret

000009d8 <InitAD>:

/* Set up the AD converter */
void InitAD(void)
{
	/* Select 5 Vref, right adjust, ADC7 */
	ADMUX = 0b01000111;
 9d8:	87 e4       	ldi	r24, 0x47	; 71
 9da:	80 93 7c 00 	sts	0x007C, r24
	/* Enable ADC, ADC interrupt, select 128 clock prescaler */
	ADCSRA = 0b10001111;
 9de:	8f e8       	ldi	r24, 0x8F	; 143
 9e0:	80 93 7a 00 	sts	0x007A, r24
	/* Disable digital input buffers on ADC0 and ADC1 */
	DIDR0 = 0b00000011;
 9e4:	83 e0       	ldi	r24, 0x03	; 3
 9e6:	80 93 7e 00 	sts	0x007E, r24
 9ea:	08 95       	ret

000009ec <CheckSwitches>:
}

/* Handle the button state */
void CheckSwitches(void)
{
	unsigned char TempPIND = PIND;
 9ec:	89 b1       	in	r24, 0x09	; 9
	/* Check Port C for any changed switches */
	lPinD ^= TempPIND;
 9ee:	90 91 0f 01 	lds	r25, 0x010F
 9f2:	98 27       	eor	r25, r24
 9f4:	90 93 0f 01 	sts	0x010F, r25

	cli();
 9f8:	f8 94       	cli
	/* Is button 1 released? */
	if(TempPIND & 0b00001000)
 9fa:	83 ff       	sbrs	r24, 3
 9fc:	22 c0       	rjmp	.+68     	; 0xa42 <CheckSwitches+0x56>
	{
		/* Was it pressed the last time we were here? */
		if(lPinD & 0b00001000)
 9fe:	90 91 0f 01 	lds	r25, 0x010F
 a02:	93 ff       	sbrs	r25, 3
 a04:	1b c0       	rjmp	.+54     	; 0xa3c <CheckSwitches+0x50>
		{
			/* Was it pressed for less than 200ms? */
			if(ButtonCnt1 < 10)
 a06:	90 91 13 01 	lds	r25, 0x0113
 a0a:	9a 30       	cpi	r25, 0x0A	; 10
 a0c:	68 f4       	brcc	.+26     	; 0xa28 <CheckSwitches+0x3c>
			{
				/* Jog 1 step negative */
				if(SetPosition) SetPosition --;
 a0e:	20 91 47 01 	lds	r18, 0x0147
 a12:	30 91 48 01 	lds	r19, 0x0148
 a16:	23 2b       	or	r18, r19
 a18:	89 f0       	breq	.+34     	; 0xa3c <CheckSwitches+0x50>
 a1a:	20 91 47 01 	lds	r18, 0x0147
 a1e:	30 91 48 01 	lds	r19, 0x0148
 a22:	21 50       	subi	r18, 0x01	; 1
 a24:	31 09       	sbc	r19, r1
 a26:	06 c0       	rjmp	.+12     	; 0xa34 <CheckSwitches+0x48>
			}
			else
			{
				SetPosition = (signed int)Position;
 a28:	20 91 02 01 	lds	r18, 0x0102
 a2c:	30 91 03 01 	lds	r19, 0x0103
 a30:	40 91 04 01 	lds	r20, 0x0104
 a34:	30 93 48 01 	sts	0x0148, r19
 a38:	20 93 47 01 	sts	0x0147, r18
			}
		}

		/* Clear our timer */
		ButtonCnt1 = 0;
 a3c:	10 92 13 01 	sts	0x0113, r1
 a40:	0e c0       	rjmp	.+28     	; 0xa5e <CheckSwitches+0x72>
	}
	else
	{
		/* If it's been pressed for more than 200ms, declare it */
		if(ButtonCnt1 == 10)
 a42:	90 91 13 01 	lds	r25, 0x0113
 a46:	9a 30       	cpi	r25, 0x0A	; 10
 a48:	39 f4       	brne	.+14     	; 0xa58 <CheckSwitches+0x6c>
		{
			/* Jog negative */
			SetPosition = -32768;
 a4a:	20 e0       	ldi	r18, 0x00	; 0
 a4c:	30 e8       	ldi	r19, 0x80	; 128
 a4e:	30 93 48 01 	sts	0x0148, r19
 a52:	20 93 47 01 	sts	0x0147, r18
 a56:	03 c0       	rjmp	.+6      	; 0xa5e <CheckSwitches+0x72>
		}
		else
		{
			/* Increment our timer */
			ButtonCnt1 ++;
 a58:	9f 5f       	subi	r25, 0xFF	; 255
 a5a:	90 93 13 01 	sts	0x0113, r25
		}
	}

	/* Is button 0 released? */
	if(TempPIND & 0b00000100)
 a5e:	82 ff       	sbrs	r24, 2
 a60:	23 c0       	rjmp	.+70     	; 0xaa8 <CheckSwitches+0xbc>
	{
		/* Was it pressed the last time we were here? */
		if(lPinD & 0b00000100)
 a62:	90 91 0f 01 	lds	r25, 0x010F
 a66:	92 ff       	sbrs	r25, 2
 a68:	1c c0       	rjmp	.+56     	; 0xaa2 <CheckSwitches+0xb6>
		{
			/* Was it pressed for less than 200ms? */
			if(ButtonCnt0 < 10)
 a6a:	90 91 45 01 	lds	r25, 0x0145
 a6e:	9a 30       	cpi	r25, 0x0A	; 10
 a70:	70 f4       	brcc	.+28     	; 0xa8e <CheckSwitches+0xa2>
			{
				/* Jog 1 step positive */
				if(~SetPosition) SetPosition ++;
 a72:	20 91 47 01 	lds	r18, 0x0147
 a76:	30 91 48 01 	lds	r19, 0x0148
 a7a:	2f 3f       	cpi	r18, 0xFF	; 255
 a7c:	3f 4f       	sbci	r19, 0xFF	; 255
 a7e:	89 f0       	breq	.+34     	; 0xaa2 <CheckSwitches+0xb6>
 a80:	20 91 47 01 	lds	r18, 0x0147
 a84:	30 91 48 01 	lds	r19, 0x0148
 a88:	2f 5f       	subi	r18, 0xFF	; 255
 a8a:	3f 4f       	sbci	r19, 0xFF	; 255
 a8c:	06 c0       	rjmp	.+12     	; 0xa9a <CheckSwitches+0xae>
			}
			else
			{
				SetPosition = (signed int)Position;
 a8e:	20 91 02 01 	lds	r18, 0x0102
 a92:	30 91 03 01 	lds	r19, 0x0103
 a96:	40 91 04 01 	lds	r20, 0x0104
 a9a:	30 93 48 01 	sts	0x0148, r19
 a9e:	20 93 47 01 	sts	0x0147, r18
			}
		}

		/* Clear our timer */
		ButtonCnt0 = 0;
 aa2:	10 92 45 01 	sts	0x0145, r1
 aa6:	0e c0       	rjmp	.+28     	; 0xac4 <CheckSwitches+0xd8>
	}
	else
	{
		/* If it's been pressed for more than 200ms, declare it */
		if(ButtonCnt0 == 10)
 aa8:	90 91 45 01 	lds	r25, 0x0145
 aac:	9a 30       	cpi	r25, 0x0A	; 10
 aae:	39 f4       	brne	.+14     	; 0xabe <CheckSwitches+0xd2>
		{
			/* Jog positive */
			SetPosition = 32767;
 ab0:	2f ef       	ldi	r18, 0xFF	; 255
 ab2:	3f e7       	ldi	r19, 0x7F	; 127
 ab4:	30 93 48 01 	sts	0x0148, r19
 ab8:	20 93 47 01 	sts	0x0147, r18
 abc:	03 c0       	rjmp	.+6      	; 0xac4 <CheckSwitches+0xd8>
		}
		else
		{
			/* Increment our timer */
			ButtonCnt0 ++;
 abe:	9f 5f       	subi	r25, 0xFF	; 255
 ac0:	90 93 45 01 	sts	0x0145, r25
		}
	}
	sei();
 ac4:	78 94       	sei

	/* Save Port C */
	lPinD = TempPIND & 0b00001100;
 ac6:	8c 70       	andi	r24, 0x0C	; 12
 ac8:	80 93 0f 01 	sts	0x010F, r24
 acc:	08 95       	ret

00000ace <LED>:

/* Handles flashing the LED */
void LED(void)
{
	/* Are we currently waiting to turn the LED off? */
	if(LEDStatus & (1<<LEDTimed))
 ace:	80 91 84 01 	lds	r24, 0x0184
 ad2:	82 ff       	sbrs	r24, 2
 ad4:	16 c0       	rjmp	.+44     	; 0xb02 <LED+0x34>
	{
		/* Has the LED been on for more than 100ms? */
		if(Tmr1ms - LEDTimer > 100)
 ad6:	80 91 82 01 	lds	r24, 0x0182
 ada:	90 91 83 01 	lds	r25, 0x0183
 ade:	20 91 3a 01 	lds	r18, 0x013A
 ae2:	30 91 3b 01 	lds	r19, 0x013B
 ae6:	82 1b       	sub	r24, r18
 ae8:	93 0b       	sbc	r25, r19
 aea:	85 36       	cpi	r24, 0x65	; 101
 aec:	91 05       	cpc	r25, r1
 aee:	58 f1       	brcs	.+86     	; 0xb46 <LED+0x78>
		{
			/* Turn it off and kill the timing flag */
			LEDStatus &= ~(1<<LEDTimed);
 af0:	80 91 84 01 	lds	r24, 0x0184
 af4:	8b 7f       	andi	r24, 0xFB	; 251
 af6:	80 93 84 01 	sts	0x0184, r24
			PORTD &= 0b01101111;
 afa:	8b b1       	in	r24, 0x0b	; 11
 afc:	8f 76       	andi	r24, 0x6F	; 111
 afe:	8b b9       	out	0x0b, r24	; 11
 b00:	08 95       	ret
		}
	}
	else
	{
		/* Has someone requested something? */
		if(LEDStatus)
 b02:	80 91 84 01 	lds	r24, 0x0184
 b06:	88 23       	and	r24, r24
 b08:	f1 f0       	breq	.+60     	; 0xb46 <LED+0x78>
		{
			/* Set up the timer */
			LEDTimer = Tmr1ms;
 b0a:	80 91 82 01 	lds	r24, 0x0182
 b0e:	90 91 83 01 	lds	r25, 0x0183
 b12:	90 93 3b 01 	sts	0x013B, r25
 b16:	80 93 3a 01 	sts	0x013A, r24
			LEDStatus |= 1<<LEDTimed;
 b1a:	80 91 84 01 	lds	r24, 0x0184
 b1e:	84 60       	ori	r24, 0x04	; 4
 b20:	80 93 84 01 	sts	0x0184, r24

			/* Has someone requested Green? */
			if(LEDStatus & (1<<LEDGreen))
 b24:	80 91 84 01 	lds	r24, 0x0184
 b28:	81 ff       	sbrs	r24, 1
 b2a:	06 c0       	rjmp	.+12     	; 0xb38 <LED+0x6a>
			{
				/* Set Green and kill the flag */
				PORTD &= 0b11101111;
 b2c:	5c 98       	cbi	0x0b, 4	; 11
				PORTD |= 0b10000000;
 b2e:	5f 9a       	sbi	0x0b, 7	; 11
				LEDStatus &= ~(1<<LEDGreen);
 b30:	80 91 84 01 	lds	r24, 0x0184
 b34:	8d 7f       	andi	r24, 0xFD	; 253
 b36:	05 c0       	rjmp	.+10     	; 0xb42 <LED+0x74>
			}
			/* If not, someone has requested Red */
			else
			{
				/* Set Red and kill the flag */
				PORTD &= 0b01111111;
 b38:	5f 98       	cbi	0x0b, 7	; 11
				PORTD |= 0b00010000;
 b3a:	5c 9a       	sbi	0x0b, 4	; 11
				LEDStatus &= ~(1<<LEDRed);
 b3c:	80 91 84 01 	lds	r24, 0x0184
 b40:	8e 7f       	andi	r24, 0xFE	; 254
 b42:	80 93 84 01 	sts	0x0184, r24
 b46:	08 95       	ret

00000b48 <main>:
{
	unsigned int TempTmr;
	unsigned int DebounceTimer;

	/* Initialize the serial system */
	InitSerial();
 b48:	30 df       	rcall	.-416    	; 0x9aa <InitSerial>

	/* Initialize the AD converter */
	InitAD();
 b4a:	46 df       	rcall	.-372    	; 0x9d8 <InitAD>

	/* Set up 1ms timer */
	OCR2A = 156;
 b4c:	8c e9       	ldi	r24, 0x9C	; 156
 b4e:	80 93 b3 00 	sts	0x00B3, r24
	TCCR2A = 0b00000010;
 b52:	82 e0       	ldi	r24, 0x02	; 2
 b54:	80 93 b0 00 	sts	0x00B0, r24
	TCCR2B = 0b00000101;
 b58:	95 e0       	ldi	r25, 0x05	; 5
 b5a:	90 93 b1 00 	sts	0x00B1, r25
	TIMSK2 = 0b00000010;
 b5e:	80 93 70 00 	sts	0x0070, r24

	/* Set up motor control timer and variables */
	TCCR1A = 0b00000000;
 b62:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0b00001000;
 b66:	98 e0       	ldi	r25, 0x08	; 8
 b68:	90 93 81 00 	sts	0x0081, r25
	TIMSK1 = 0b00000010;
 b6c:	80 93 6f 00 	sts	0x006F, r24

	Temperature = 0xEFFF;
 b70:	8f ef       	ldi	r24, 0xFF	; 255
 b72:	9f ee       	ldi	r25, 0xEF	; 239
 b74:	90 93 0a 01 	sts	0x010A, r25
 b78:	80 93 09 01 	sts	0x0109, r24
	MaxVel = eeprom_read_word(&saveMaxVel);
 b7c:	82 e0       	ldi	r24, 0x02	; 2
 b7e:	90 e0       	ldi	r25, 0x00	; 0
 b80:	12 d2       	rcall	.+1060   	; 0xfa6 <__eerd_word_m48>
 b82:	90 93 7c 01 	sts	0x017C, r25
 b86:	80 93 7b 01 	sts	0x017B, r24
	CalcMaxVel100();
 b8a:	01 df       	rcall	.-510    	; 0x98e <CalcMaxVel100>
	MaxAccel = eeprom_read_byte(&saveAccel);
 b8c:	81 e0       	ldi	r24, 0x01	; 1
 b8e:	90 e0       	ldi	r25, 0x00	; 0
 b90:	02 d2       	rcall	.+1028   	; 0xf96 <__eerd_byte_m48>
 b92:	80 93 0b 01 	sts	0x010B, r24
	if(eeprom_read_byte(&saveIdle))	MotStatus |= 1<<IdleOff;
 b96:	80 e0       	ldi	r24, 0x00	; 0
 b98:	90 e0       	ldi	r25, 0x00	; 0
 b9a:	fd d1       	rcall	.+1018   	; 0xf96 <__eerd_byte_m48>
 b9c:	88 23       	and	r24, r24
 b9e:	29 f0       	breq	.+10     	; 0xbaa <main+0x62>
 ba0:	80 91 12 01 	lds	r24, 0x0112
 ba4:	81 60       	ori	r24, 0x01	; 1
 ba6:	80 93 12 01 	sts	0x0112, r24
	SafeStopVel = CalcSafeStopVel(MaxAccel);
 baa:	80 91 0b 01 	lds	r24, 0x010B
 bae:	bf de       	rcall	.-642    	; 0x92e <CalcSafeStopVel>
 bb0:	70 93 39 01 	sts	0x0139, r23
 bb4:	60 93 38 01 	sts	0x0138, r22
	 * B1, B2 Motor control outputs
	 * D0 TX
	 * D4, D5 Motor control outputs
	 * D6, D7 LED outputs
	 */
	DDRB = 0b00000110;
 bb8:	86 e0       	ldi	r24, 0x06	; 6
 bba:	84 b9       	out	0x04, r24	; 4
	DDRC = 0b00000000;
 bbc:	17 b8       	out	0x07, r1	; 7
	DDRD = 0b11110001;
 bbe:	81 ef       	ldi	r24, 0xF1	; 241
 bc0:	8a b9       	out	0x0a, r24	; 10
	/* Enable pull ups on D2, D3 Buttons */
	PORTD |= 0b00001100;
 bc2:	8b b1       	in	r24, 0x0b	; 11
 bc4:	8c 60       	ori	r24, 0x0C	; 12
 bc6:	8b b9       	out	0x0b, r24	; 11
	/* Set last button pin state */
	lPinD = PIND & 0b00001100;
 bc8:	89 b1       	in	r24, 0x09	; 9
 bca:	8c 70       	andi	r24, 0x0C	; 12
 bcc:	80 93 0f 01 	sts	0x010F, r24

	/* Initialize the button handler */
	CheckSwitches();
 bd0:	0d df       	rcall	.-486    	; 0x9ec <CheckSwitches>

	/* Initialize main loop timers */
	TempTmr = Tmr1ms;
 bd2:	00 91 82 01 	lds	r16, 0x0182
 bd6:	10 91 83 01 	lds	r17, 0x0183
	DebounceTimer = Tmr1ms;
 bda:	e0 90 82 01 	lds	r14, 0x0182
 bde:	f0 90 83 01 	lds	r15, 0x0183

	/* Start the show */
	sei();
 be2:	78 94       	sei

	/* Indicate that we've started up by flashing both colors */
	LEDStatus = (1<<LEDRed) | (1<<LEDGreen);
 be4:	83 e0       	ldi	r24, 0x03	; 3
 be6:	80 93 84 01 	sts	0x0184, r24
				{
					TempADC = lADC<<4;
				}
				else
				{
					TempADC = (signed int)TempADC + ((long)(lADC<<4) - (signed int)TempADC)/16;
 bea:	50 e1       	ldi	r21, 0x10	; 16
 bec:	85 2e       	mov	r8, r21
 bee:	91 2c       	mov	r9, r1
 bf0:	a1 2c       	mov	r10, r1
 bf2:	b1 2c       	mov	r11, r1

			/* Is the ADC value unreasonable? */
			if(lADC > 0x3F0 || lADC < 0x010)
			{
				/* Indicate that something is wrong */
				Temperature = 0xEFFF;
 bf4:	cc 24       	eor	r12, r12
 bf6:	ca 94       	dec	r12
 bf8:	6f ee       	ldi	r22, 0xEF	; 239
 bfa:	d6 2e       	mov	r13, r22
	while(1)
	{
		unsigned int localTmr1ms;

		/* Get the current time */
		cli();
 bfc:	f8 94       	cli
		localTmr1ms = Tmr1ms;
 bfe:	c0 91 82 01 	lds	r28, 0x0182
 c02:	d0 91 83 01 	lds	r29, 0x0183
		sei();
 c06:	78 94       	sei

		/* Process any received serial commands, if they exist */
		if(SerStatus & (1<<SerNewRx)) ProcessRx();
 c08:	80 91 0e 01 	lds	r24, 0x010E
 c0c:	80 fd       	sbrc	r24, 0
 c0e:	67 da       	rcall	.-2866   	; 0xde <ProcessRx>

		/* Has our command timer timed out while a command was in progress? */
		if((localTmr1ms - CmdTimer > 1000) && (CmdStatus & (1<<CmdInProg)))
 c10:	80 91 00 01 	lds	r24, 0x0100
 c14:	90 91 01 01 	lds	r25, 0x0101
 c18:	9e 01       	movw	r18, r28
 c1a:	28 1b       	sub	r18, r24
 c1c:	39 0b       	sbc	r19, r25
 c1e:	c9 01       	movw	r24, r18
 c20:	89 3e       	cpi	r24, 0xE9	; 233
 c22:	93 40       	sbci	r25, 0x03	; 3
 c24:	78 f0       	brcs	.+30     	; 0xc44 <main+0xfc>
 c26:	80 91 3d 01 	lds	r24, 0x013D
 c2a:	87 ff       	sbrs	r24, 7
 c2c:	0b c0       	rjmp	.+22     	; 0xc44 <main+0xfc>
		{
			/* Clear the command status and send back an invalid command byte */
			CmdStatus &= ~(1<<CmdInProg);
 c2e:	8f 77       	andi	r24, 0x7F	; 127
 c30:	80 93 3d 01 	sts	0x013D, r24
			AddToTx(CmdDataRec*16, &CmdData[0], CmdDataRec);
 c34:	80 91 3c 01 	lds	r24, 0x013C
 c38:	48 2f       	mov	r20, r24
 c3a:	69 e4       	ldi	r22, 0x49	; 73
 c3c:	71 e0       	ldi	r23, 0x01	; 1
 c3e:	82 95       	swap	r24
 c40:	80 7f       	andi	r24, 0xF0	; 240
 c42:	1a da       	rcall	.-3020   	; 0x78 <AddToTx>
		}

		/* Handle the LED */
		LED();
 c44:	44 df       	rcall	.-376    	; 0xace <LED>

		/* Are we waiting to turn off the motor? */
		if(MotStatus & 1<<IdleOffInProg)
 c46:	80 91 12 01 	lds	r24, 0x0112
 c4a:	81 ff       	sbrs	r24, 1
 c4c:	19 c0       	rjmp	.+50     	; 0xc80 <main+0x138>
		{
			/* Has a second elapsed since we stopped moving? */
			if(localTmr1ms - IdleTimer > 1000)
 c4e:	80 91 0c 01 	lds	r24, 0x010C
 c52:	90 91 0d 01 	lds	r25, 0x010D
 c56:	9e 01       	movw	r18, r28
 c58:	28 1b       	sub	r18, r24
 c5a:	39 0b       	sbc	r19, r25
 c5c:	c9 01       	movw	r24, r18
 c5e:	89 3e       	cpi	r24, 0xE9	; 233
 c60:	93 40       	sbci	r25, 0x03	; 3
 c62:	f8 f0       	brcs	.+62     	; 0xca2 <main+0x15a>
			{
				/* Keep the ISR out of our business */
				cli();
 c64:	f8 94       	cli
				/* Is the step timer disabled? */
				if((TCCR1B & 0b00000101) == 0)
 c66:	80 91 81 00 	lds	r24, 0x0081
 c6a:	85 70       	andi	r24, 0x05	; 5
 c6c:	11 f4       	brne	.+4      	; 0xc72 <main+0x12a>
				{
					/* Turn off the motor */
					Step(8);
 c6e:	88 e0       	ldi	r24, 0x08	; 8
 c70:	fd d0       	rcall	.+506    	; 0xe6c <Step>
				}
				/* Clear the flag */
				MotStatus &= ~(1<<IdleOffInProg);
 c72:	80 91 12 01 	lds	r24, 0x0112
 c76:	8d 7f       	andi	r24, 0xFD	; 253
 c78:	80 93 12 01 	sts	0x0112, r24
				sei();
 c7c:	78 94       	sei
 c7e:	11 c0       	rjmp	.+34     	; 0xca2 <main+0x15a>
			}
		}
		else if(MotStatus & 1<<IdleOff)
 c80:	80 91 12 01 	lds	r24, 0x0112
 c84:	80 ff       	sbrs	r24, 0
 c86:	0d c0       	rjmp	.+26     	; 0xca2 <main+0x15a>
		{
			/* Is the motor stopped? */
			if((TCCR1B & 0b00000101) == 0)
 c88:	80 91 81 00 	lds	r24, 0x0081
 c8c:	85 70       	andi	r24, 0x05	; 5
 c8e:	49 f4       	brne	.+18     	; 0xca2 <main+0x15a>
			{
				/* Indicate that we're waiting to kill power */
				MotStatus |= 1<<IdleOffInProg;
 c90:	80 91 12 01 	lds	r24, 0x0112
 c94:	82 60       	ori	r24, 0x02	; 2
 c96:	80 93 12 01 	sts	0x0112, r24
				/* Save off the current time */
				IdleTimer = localTmr1ms;
 c9a:	d0 93 0d 01 	sts	0x010D, r29
 c9e:	c0 93 0c 01 	sts	0x010C, r28
			}
		}

		/* Is it time to check for a button press? */
		if(localTmr1ms - DebounceTimer >= 20)
 ca2:	ce 01       	movw	r24, r28
 ca4:	8e 19       	sub	r24, r14
 ca6:	9f 09       	sbc	r25, r15
 ca8:	44 97       	sbiw	r24, 0x14	; 20
 caa:	10 f0       	brcs	.+4      	; 0xcb0 <main+0x168>
		{
			/* Save the time */
			DebounceTimer = localTmr1ms;

			/* Update the button state */
			CheckSwitches();
 cac:	9f de       	rcall	.-706    	; 0x9ec <CheckSwitches>

		/* Is it time to check for a button press? */
		if(localTmr1ms - DebounceTimer >= 20)
		{
			/* Save the time */
			DebounceTimer = localTmr1ms;
 cae:	7e 01       	movw	r14, r28
			/* Update the button state */
			CheckSwitches();
		}

		/* Is it time to attempt a temperature measurement? */
		if(localTmr1ms - TempTmr >= 500) //TempTimeout)
 cb0:	ce 01       	movw	r24, r28
 cb2:	80 1b       	sub	r24, r16
 cb4:	91 0b       	sbc	r25, r17
 cb6:	84 3f       	cpi	r24, 0xF4	; 244
 cb8:	91 40       	sbci	r25, 0x01	; 1
 cba:	c0 f0       	brcs	.+48     	; 0xcec <main+0x1a4>
			TempTmr = localTmr1ms;

			/* Initiate a Temp conversion if we aren't waiting to process a previous conversion
			 * or are in the middle of one
			 */
			if((~ADCStatus & 0x01) && (~ADCSRA & 0b01000000))
 cbc:	80 91 7a 01 	lds	r24, 0x017A
 cc0:	80 fd       	sbrc	r24, 0
 cc2:	15 c0       	rjmp	.+42     	; 0xcee <main+0x1a6>
 cc4:	80 91 7a 00 	lds	r24, 0x007A
 cc8:	86 fd       	sbrc	r24, 6
 cca:	11 c0       	rjmp	.+34     	; 0xcee <main+0x1a6>
			{
				/* Select ADC7 */
				ADMUX &= 0b01110000;
 ccc:	80 91 7c 00 	lds	r24, 0x007C
 cd0:	80 77       	andi	r24, 0x70	; 112
 cd2:	80 93 7c 00 	sts	0x007C, r24
				ADMUX |= 0b00000111;
 cd6:	80 91 7c 00 	lds	r24, 0x007C
 cda:	87 60       	ori	r24, 0x07	; 7
 cdc:	80 93 7c 00 	sts	0x007C, r24
				/* Start conversion */
				ADCSRA |= 0b01000000;
 ce0:	80 91 7a 00 	lds	r24, 0x007A
 ce4:	80 64       	ori	r24, 0x40	; 64
 ce6:	80 93 7a 00 	sts	0x007A, r24
 cea:	01 c0       	rjmp	.+2      	; 0xcee <main+0x1a6>
 cec:	e8 01       	movw	r28, r16
			}
		}

		/* Do we have an AD conversion to process? */
		if(ADCStatus & 0x01)
 cee:	80 91 7a 01 	lds	r24, 0x017A
 cf2:	80 fd       	sbrc	r24, 0
 cf4:	02 c0       	rjmp	.+4      	; 0xcfa <main+0x1b2>
		}
	}
}

int main(void)
{
 cf6:	8e 01       	movw	r16, r28
 cf8:	81 cf       	rjmp	.-254    	; 0xbfc <main+0xb4>

		/* Do we have an AD conversion to process? */
		if(ADCStatus & 0x01)
		{
			/* Kill the flag */
			ADCStatus &= ~0x01;
 cfa:	80 91 7a 01 	lds	r24, 0x017A
 cfe:	8e 7f       	andi	r24, 0xFE	; 254
 d00:	80 93 7a 01 	sts	0x017A, r24

			/* Store a local copy of ADC */
			unsigned int lADC = ADC;
 d04:	60 91 78 00 	lds	r22, 0x0078
 d08:	70 91 79 00 	lds	r23, 0x0079

			/* Is the ADC value unreasonable? */
			if(lADC > 0x3F0 || lADC < 0x010)
 d0c:	cb 01       	movw	r24, r22
 d0e:	40 97       	sbiw	r24, 0x10	; 16
 d10:	81 3e       	cpi	r24, 0xE1	; 225
 d12:	93 40       	sbci	r25, 0x03	; 3
 d14:	28 f0       	brcs	.+10     	; 0xd20 <main+0x1d8>
			{
				/* Indicate that something is wrong */
				Temperature = 0xEFFF;
 d16:	d0 92 0a 01 	sts	0x010A, r13
 d1a:	c0 92 09 01 	sts	0x0109, r12
 d1e:	eb cf       	rjmp	.-42     	; 0xcf6 <main+0x1ae>
			}
			else
			{
				if(Temperature == 0xEFFF)
 d20:	80 91 09 01 	lds	r24, 0x0109
 d24:	90 91 0a 01 	lds	r25, 0x010A
 d28:	44 e0       	ldi	r20, 0x04	; 4
 d2a:	66 0f       	add	r22, r22
 d2c:	77 1f       	adc	r23, r23
 d2e:	4a 95       	dec	r20
 d30:	e1 f7       	brne	.-8      	; 0xd2a <main+0x1e2>
 d32:	8f 3f       	cpi	r24, 0xFF	; 255
 d34:	9f 4e       	sbci	r25, 0xEF	; 239
 d36:	29 f4       	brne	.+10     	; 0xd42 <main+0x1fa>
				{
					TempADC = lADC<<4;
 d38:	70 93 37 01 	sts	0x0137, r23
 d3c:	60 93 36 01 	sts	0x0136, r22
 d40:	1b c0       	rjmp	.+54     	; 0xd78 <main+0x230>
				}
				else
				{
					TempADC = (signed int)TempADC + ((long)(lADC<<4) - (signed int)TempADC)/16;
 d42:	00 91 36 01 	lds	r16, 0x0136
 d46:	10 91 37 01 	lds	r17, 0x0137
 d4a:	cb 01       	movw	r24, r22
 d4c:	a0 e0       	ldi	r26, 0x00	; 0
 d4e:	b0 e0       	ldi	r27, 0x00	; 0
 d50:	28 01       	movw	r4, r16
 d52:	66 24       	eor	r6, r6
 d54:	57 fc       	sbrc	r5, 7
 d56:	60 94       	com	r6
 d58:	76 2c       	mov	r7, r6
 d5a:	bc 01       	movw	r22, r24
 d5c:	cd 01       	movw	r24, r26
 d5e:	64 19       	sub	r22, r4
 d60:	75 09       	sbc	r23, r5
 d62:	86 09       	sbc	r24, r6
 d64:	97 09       	sbc	r25, r7
 d66:	a5 01       	movw	r20, r10
 d68:	94 01       	movw	r18, r8
 d6a:	d7 d0       	rcall	.+430    	; 0xf1a <__divmodsi4>
 d6c:	20 0f       	add	r18, r16
 d6e:	31 1f       	adc	r19, r17
 d70:	30 93 37 01 	sts	0x0137, r19
 d74:	20 93 36 01 	sts	0x0136, r18
				}

				lADC = TempADC/16;
 d78:	80 91 36 01 	lds	r24, 0x0136
 d7c:	90 91 37 01 	lds	r25, 0x0137
 d80:	34 e0       	ldi	r19, 0x04	; 4
 d82:	96 95       	lsr	r25
 d84:	87 95       	ror	r24
 d86:	3a 95       	dec	r19
 d88:	e1 f7       	brne	.-8      	; 0xd82 <main+0x23a>
				unsigned int slope;
				signed int intercept;
				unsigned int offset;

				/* Do linear interpolation to find the temperature *10 */
				if(lADC < 277)
 d8a:	85 31       	cpi	r24, 0x15	; 21
 d8c:	31 e0       	ldi	r19, 0x01	; 1
 d8e:	93 07       	cpc	r25, r19
 d90:	58 f0       	brcs	.+22     	; 0xda8 <main+0x260>
				{
					slope = 279;
					intercept = 800;
					offset = 276;
				}
				else if (lADC < 876)
 d92:	8c 36       	cpi	r24, 0x6C	; 108
 d94:	23 e0       	ldi	r18, 0x03	; 3
 d96:	92 07       	cpc	r25, r18
 d98:	70 f0       	brcs	.+28     	; 0xdb6 <main+0x26e>
				}
				else
				{
					slope = 335;
					intercept = -200;
					offset = 989;
 d9a:	2d ed       	ldi	r18, 0xDD	; 221
 d9c:	33 e0       	ldi	r19, 0x03	; 3
					offset = 875;
				}
				else
				{
					slope = 335;
					intercept = -200;
 d9e:	e8 e3       	ldi	r30, 0x38	; 56
 da0:	ff ef       	ldi	r31, 0xFF	; 255
					intercept = 100;
					offset = 875;
				}
				else
				{
					slope = 335;
 da2:	6f e4       	ldi	r22, 0x4F	; 79
 da4:	71 e0       	ldi	r23, 0x01	; 1
 da6:	0d c0       	rjmp	.+26     	; 0xdc2 <main+0x27a>
				/* Do linear interpolation to find the temperature *10 */
				if(lADC < 277)
				{
					slope = 279;
					intercept = 800;
					offset = 276;
 da8:	24 e1       	ldi	r18, 0x14	; 20
 daa:	31 e0       	ldi	r19, 0x01	; 1

				/* Do linear interpolation to find the temperature *10 */
				if(lADC < 277)
				{
					slope = 279;
					intercept = 800;
 dac:	e0 e2       	ldi	r30, 0x20	; 32
 dae:	f3 e0       	ldi	r31, 0x03	; 3
				unsigned int offset;

				/* Do linear interpolation to find the temperature *10 */
				if(lADC < 277)
				{
					slope = 279;
 db0:	67 e1       	ldi	r22, 0x17	; 23
 db2:	71 e0       	ldi	r23, 0x01	; 1
 db4:	06 c0       	rjmp	.+12     	; 0xdc2 <main+0x27a>
				}
				else if (lADC < 876)
				{
					slope = 150;
					intercept = 100;
					offset = 875;
 db6:	2b e6       	ldi	r18, 0x6B	; 107
 db8:	33 e0       	ldi	r19, 0x03	; 3
					offset = 276;
				}
				else if (lADC < 876)
				{
					slope = 150;
					intercept = 100;
 dba:	e4 e6       	ldi	r30, 0x64	; 100
 dbc:	f0 e0       	ldi	r31, 0x00	; 0
					intercept = 800;
					offset = 276;
				}
				else if (lADC < 876)
				{
					slope = 150;
 dbe:	66 e9       	ldi	r22, 0x96	; 150
 dc0:	70 e0       	ldi	r23, 0x00	; 0
					slope = 335;
					intercept = -200;
					offset = 989;
				}

				Temperature = (signed int)((((__int24)offset - (__int24)lADC) * slope)>>7) + intercept;
 dc2:	40 e0       	ldi	r20, 0x00	; 0
 dc4:	28 1b       	sub	r18, r24
 dc6:	39 0b       	sbc	r19, r25
 dc8:	41 09       	sbc	r20, r1
 dca:	80 e0       	ldi	r24, 0x00	; 0
 dcc:	84 d0       	rcall	.+264    	; 0xed6 <__mulpsi3>
 dce:	a8 2f       	mov	r26, r24
 dd0:	cb 01       	movw	r24, r22
 dd2:	37 e0       	ldi	r19, 0x07	; 7
 dd4:	a5 95       	asr	r26
 dd6:	97 95       	ror	r25
 dd8:	87 95       	ror	r24
 dda:	3a 95       	dec	r19
 ddc:	d9 f7       	brne	.-10     	; 0xdd4 <main+0x28c>
 dde:	e8 0f       	add	r30, r24
 de0:	f9 1f       	adc	r31, r25
 de2:	f0 93 0a 01 	sts	0x010A, r31
 de6:	e0 93 09 01 	sts	0x0109, r30

				/* Is temp comp enabled? */
				if(TempCoeff)
 dea:	20 91 05 01 	lds	r18, 0x0105
 dee:	30 91 06 01 	lds	r19, 0x0106
 df2:	21 15       	cp	r18, r1
 df4:	31 05       	cpc	r19, r1
 df6:	09 f4       	brne	.+2      	; 0xdfa <main+0x2b2>
 df8:	7e cf       	rjmp	.-260    	; 0xcf6 <main+0x1ae>
				{
					/* Update the set point based on the temperature change since comp was enabled */
					SetPosition = BasePosition + (((Temperature - BaseTemp) * TempCoeff)/16);
 dfa:	80 91 34 01 	lds	r24, 0x0134
 dfe:	90 91 35 01 	lds	r25, 0x0135
 e02:	e8 1b       	sub	r30, r24
 e04:	f9 0b       	sbc	r31, r25
 e06:	e2 9f       	mul	r30, r18
 e08:	c0 01       	movw	r24, r0
 e0a:	e3 9f       	mul	r30, r19
 e0c:	90 0d       	add	r25, r0
 e0e:	f2 9f       	mul	r31, r18
 e10:	90 0d       	add	r25, r0
 e12:	11 24       	eor	r1, r1
 e14:	97 fd       	sbrc	r25, 7
 e16:	0f 96       	adiw	r24, 0x0f	; 15
 e18:	24 e0       	ldi	r18, 0x04	; 4
 e1a:	95 95       	asr	r25
 e1c:	87 95       	ror	r24
 e1e:	2a 95       	dec	r18
 e20:	e1 f7       	brne	.-8      	; 0xe1a <main+0x2d2>
 e22:	20 91 40 01 	lds	r18, 0x0140
 e26:	30 91 41 01 	lds	r19, 0x0141
 e2a:	82 0f       	add	r24, r18
 e2c:	93 1f       	adc	r25, r19
 e2e:	90 93 48 01 	sts	0x0148, r25
 e32:	80 93 47 01 	sts	0x0147, r24
 e36:	5f cf       	rjmp	.-322    	; 0xcf6 <main+0x1ae>

00000e38 <CalcDelay>:

#include "ufocus.h"

/* Calculates what our step delay is for a given velocity */
unsigned int CalcDelay(__uint24 AbsVel)
{
 e38:	9b 01       	movw	r18, r22
 e3a:	48 2f       	mov	r20, r24
	if(AbsVel > SafeStopVel)
 e3c:	80 91 38 01 	lds	r24, 0x0138
 e40:	90 91 39 01 	lds	r25, 0x0139
 e44:	a0 e0       	ldi	r26, 0x00	; 0
 e46:	82 17       	cp	r24, r18
 e48:	93 07       	cpc	r25, r19
 e4a:	a4 07       	cpc	r26, r20
 e4c:	10 f4       	brcc	.+4      	; 0xe52 <CalcDelay+0x1a>
	{
		return (unsigned int)(StepTimerFreq / AbsVel);
 e4e:	50 e0       	ldi	r21, 0x00	; 0
 e50:	06 c0       	rjmp	.+12     	; 0xe5e <CalcDelay+0x26>
	}
	else
	{
		return (unsigned int)(StepTimerFreq / SafeStopVel);
 e52:	20 91 38 01 	lds	r18, 0x0138
 e56:	30 91 39 01 	lds	r19, 0x0139
 e5a:	40 e0       	ldi	r20, 0x00	; 0
 e5c:	50 e0       	ldi	r21, 0x00	; 0
 e5e:	6c e4       	ldi	r22, 0x4C	; 76
 e60:	7d ec       	ldi	r23, 0xCD	; 205
 e62:	8d e1       	ldi	r24, 0x1D	; 29
 e64:	90 e0       	ldi	r25, 0x00	; 0
 e66:	59 d0       	rcall	.+178    	; 0xf1a <__divmodsi4>
 e68:	c9 01       	movw	r24, r18
	}
}
 e6a:	08 95       	ret

00000e6c <Step>:
 * PB1 - M21
 * PB2 - M22
 */
void Step(unsigned char phase)
{
	switch(phase)
 e6c:	90 e0       	ldi	r25, 0x00	; 0
 e6e:	88 30       	cpi	r24, 0x08	; 8
 e70:	91 05       	cpc	r25, r1
 e72:	50 f5       	brcc	.+84     	; 0xec8 <Step+0x5c>
 e74:	fc 01       	movw	r30, r24
 e76:	ed 5d       	subi	r30, 0xDD	; 221
 e78:	ff 4f       	sbci	r31, 0xFF	; 255
 e7a:	09 94       	ijmp
		 * Out11 - H
		 * Out12 - L
		 * Out21 - Off
		 * Out22 - Off
		 */
		PORTD &= 0b11011111;
 e7c:	5d 98       	cbi	0x0b, 5	; 11
		PORTD |= 0b01000000;
 e7e:	5e 9a       	sbi	0x0b, 6	; 11
 e80:	10 c0       	rjmp	.+32     	; 0xea2 <Step+0x36>
		 * Out11 - H
		 * Out12 - L
		 * Out21 - L
		 * Out22 - H
		 */
		PORTD &= 0b11011111;
 e82:	5d 98       	cbi	0x0b, 5	; 11
		PORTD |= 0b01000000;
 e84:	5e 9a       	sbi	0x0b, 6	; 11
 e86:	08 c0       	rjmp	.+16     	; 0xe98 <Step+0x2c>
		 * Out11 - Off
		 * Out12 - Off
		 * Out21 - L
		 * Out22 - H
		 */
		PORTD &= 0b10011111;
 e88:	8b b1       	in	r24, 0x0b	; 11
 e8a:	8f 79       	andi	r24, 0x9F	; 159
 e8c:	8b b9       	out	0x0b, r24	; 11
		PORTD |= 0b00000000;
 e8e:	8b b1       	in	r24, 0x0b	; 11
 e90:	8b b9       	out	0x0b, r24	; 11
 e92:	02 c0       	rjmp	.+4      	; 0xe98 <Step+0x2c>
		 * Out11 - L
		 * Out12 - H
		 * Out21 - L
		 * Out22 - H
		 */
		PORTD &= 0b10111111;
 e94:	5e 98       	cbi	0x0b, 6	; 11
		PORTD |= 0b00100000;
 e96:	5d 9a       	sbi	0x0b, 5	; 11
		PORTB &= 0b11111101;
 e98:	29 98       	cbi	0x05, 1	; 5
		PORTB |= 0b00000100;
 e9a:	2a 9a       	sbi	0x05, 2	; 5
		break;
 e9c:	08 95       	ret
		 * Out11 - L
		 * Out12 - H
		 * Out21 - Off
		 * Out22 - Off
		 */
		PORTD &= 0b10111111;
 e9e:	5e 98       	cbi	0x0b, 6	; 11
		PORTD |= 0b00100000;
 ea0:	5d 9a       	sbi	0x0b, 5	; 11
		PORTB &= 0b11111001;
 ea2:	85 b1       	in	r24, 0x05	; 5
 ea4:	89 7f       	andi	r24, 0xF9	; 249
 ea6:	85 b9       	out	0x05, r24	; 5
		PORTB |= 0b00000000;
 ea8:	85 b1       	in	r24, 0x05	; 5
 eaa:	13 c0       	rjmp	.+38     	; 0xed2 <Step+0x66>
		 * Out11 - L
		 * Out12 - H
		 * Out21 - H
		 * Out22 - L
		 */
		PORTD &= 0b10111111;
 eac:	5e 98       	cbi	0x0b, 6	; 11
		PORTD |= 0b00100000;
 eae:	5d 9a       	sbi	0x0b, 5	; 11
 eb0:	08 c0       	rjmp	.+16     	; 0xec2 <Step+0x56>
		 * Out11 - Off
		 * Out12 - Off
		 * Out21 - H
		 * Out22 - L
		 */
		PORTD &= 0b10011111;
 eb2:	8b b1       	in	r24, 0x0b	; 11
 eb4:	8f 79       	andi	r24, 0x9F	; 159
 eb6:	8b b9       	out	0x0b, r24	; 11
		PORTD |= 0b00000000;
 eb8:	8b b1       	in	r24, 0x0b	; 11
 eba:	8b b9       	out	0x0b, r24	; 11
 ebc:	02 c0       	rjmp	.+4      	; 0xec2 <Step+0x56>
		 * Out11 - H
		 * Out12 - L
		 * Out21 - H
		 * Out22 - L
		 */
		PORTD &= 0b11011111;
 ebe:	5d 98       	cbi	0x0b, 5	; 11
		PORTD |= 0b01000000;
 ec0:	5e 9a       	sbi	0x0b, 6	; 11
		PORTB &= 0b11111011;
 ec2:	2a 98       	cbi	0x05, 2	; 5
		PORTB |= 0b00000010;
 ec4:	29 9a       	sbi	0x05, 1	; 5
		break;
 ec6:	08 95       	ret
		 * Out11 - Off
		 * Out12 - Off
		 * Out21 - Off
		 * Out22 - Off
		 */
		PORTD &= 0b10011111;
 ec8:	8b b1       	in	r24, 0x0b	; 11
 eca:	8f 79       	andi	r24, 0x9F	; 159
 ecc:	8b b9       	out	0x0b, r24	; 11
		PORTB &= 0b11111001;
 ece:	85 b1       	in	r24, 0x05	; 5
 ed0:	89 7f       	andi	r24, 0xF9	; 249
 ed2:	85 b9       	out	0x05, r24	; 5
 ed4:	08 95       	ret

00000ed6 <__mulpsi3>:
 ed6:	db 01       	movw	r26, r22
 ed8:	58 2f       	mov	r21, r24
 eda:	13 d0       	rcall	.+38     	; 0xf02 <__umulhisi3>
 edc:	52 9f       	mul	r21, r18
 ede:	80 0d       	add	r24, r0
 ee0:	a4 9f       	mul	r26, r20
 ee2:	80 0d       	add	r24, r0
 ee4:	11 24       	eor	r1, r1
 ee6:	08 95       	ret

00000ee8 <__mulsqipsi3>:
 ee8:	69 9f       	mul	r22, r25
 eea:	90 01       	movw	r18, r0
 eec:	89 9f       	mul	r24, r25
 eee:	40 2d       	mov	r20, r0
 ef0:	79 9f       	mul	r23, r25
 ef2:	30 0d       	add	r19, r0
 ef4:	41 1d       	adc	r20, r1
 ef6:	11 24       	eor	r1, r1
 ef8:	97 ff       	sbrs	r25, 7
 efa:	08 95       	ret
 efc:	36 1b       	sub	r19, r22
 efe:	47 0b       	sbc	r20, r23
 f00:	08 95       	ret

00000f02 <__umulhisi3>:
 f02:	a2 9f       	mul	r26, r18
 f04:	b0 01       	movw	r22, r0
 f06:	b3 9f       	mul	r27, r19
 f08:	c0 01       	movw	r24, r0
 f0a:	a3 9f       	mul	r26, r19
 f0c:	01 d0       	rcall	.+2      	; 0xf10 <__umulhisi3+0xe>
 f0e:	b2 9f       	mul	r27, r18
 f10:	70 0d       	add	r23, r0
 f12:	81 1d       	adc	r24, r1
 f14:	11 24       	eor	r1, r1
 f16:	91 1d       	adc	r25, r1
 f18:	08 95       	ret

00000f1a <__divmodsi4>:
 f1a:	05 2e       	mov	r0, r21
 f1c:	97 fb       	bst	r25, 7
 f1e:	16 f4       	brtc	.+4      	; 0xf24 <__divmodsi4+0xa>
 f20:	00 94       	com	r0
 f22:	0f d0       	rcall	.+30     	; 0xf42 <__negsi2>
 f24:	57 fd       	sbrc	r21, 7
 f26:	05 d0       	rcall	.+10     	; 0xf32 <__divmodsi4_neg2>
 f28:	14 d0       	rcall	.+40     	; 0xf52 <__udivmodsi4>
 f2a:	07 fc       	sbrc	r0, 7
 f2c:	02 d0       	rcall	.+4      	; 0xf32 <__divmodsi4_neg2>
 f2e:	46 f4       	brtc	.+16     	; 0xf40 <__divmodsi4_exit>
 f30:	08 c0       	rjmp	.+16     	; 0xf42 <__negsi2>

00000f32 <__divmodsi4_neg2>:
 f32:	50 95       	com	r21
 f34:	40 95       	com	r20
 f36:	30 95       	com	r19
 f38:	21 95       	neg	r18
 f3a:	3f 4f       	sbci	r19, 0xFF	; 255
 f3c:	4f 4f       	sbci	r20, 0xFF	; 255
 f3e:	5f 4f       	sbci	r21, 0xFF	; 255

00000f40 <__divmodsi4_exit>:
 f40:	08 95       	ret

00000f42 <__negsi2>:
 f42:	90 95       	com	r25
 f44:	80 95       	com	r24
 f46:	70 95       	com	r23
 f48:	61 95       	neg	r22
 f4a:	7f 4f       	sbci	r23, 0xFF	; 255
 f4c:	8f 4f       	sbci	r24, 0xFF	; 255
 f4e:	9f 4f       	sbci	r25, 0xFF	; 255
 f50:	08 95       	ret

00000f52 <__udivmodsi4>:
 f52:	a1 e2       	ldi	r26, 0x21	; 33
 f54:	1a 2e       	mov	r1, r26
 f56:	aa 1b       	sub	r26, r26
 f58:	bb 1b       	sub	r27, r27
 f5a:	fd 01       	movw	r30, r26
 f5c:	0d c0       	rjmp	.+26     	; 0xf78 <__udivmodsi4_ep>

00000f5e <__udivmodsi4_loop>:
 f5e:	aa 1f       	adc	r26, r26
 f60:	bb 1f       	adc	r27, r27
 f62:	ee 1f       	adc	r30, r30
 f64:	ff 1f       	adc	r31, r31
 f66:	a2 17       	cp	r26, r18
 f68:	b3 07       	cpc	r27, r19
 f6a:	e4 07       	cpc	r30, r20
 f6c:	f5 07       	cpc	r31, r21
 f6e:	20 f0       	brcs	.+8      	; 0xf78 <__udivmodsi4_ep>
 f70:	a2 1b       	sub	r26, r18
 f72:	b3 0b       	sbc	r27, r19
 f74:	e4 0b       	sbc	r30, r20
 f76:	f5 0b       	sbc	r31, r21

00000f78 <__udivmodsi4_ep>:
 f78:	66 1f       	adc	r22, r22
 f7a:	77 1f       	adc	r23, r23
 f7c:	88 1f       	adc	r24, r24
 f7e:	99 1f       	adc	r25, r25
 f80:	1a 94       	dec	r1
 f82:	69 f7       	brne	.-38     	; 0xf5e <__udivmodsi4_loop>
 f84:	60 95       	com	r22
 f86:	70 95       	com	r23
 f88:	80 95       	com	r24
 f8a:	90 95       	com	r25
 f8c:	9b 01       	movw	r18, r22
 f8e:	ac 01       	movw	r20, r24
 f90:	bd 01       	movw	r22, r26
 f92:	cf 01       	movw	r24, r30
 f94:	08 95       	ret

00000f96 <__eerd_byte_m48>:
 f96:	f9 99       	sbic	0x1f, 1	; 31
 f98:	fe cf       	rjmp	.-4      	; 0xf96 <__eerd_byte_m48>
 f9a:	12 bc       	out	0x22, r1	; 34
 f9c:	81 bd       	out	0x21, r24	; 33
 f9e:	f8 9a       	sbi	0x1f, 0	; 31
 fa0:	99 27       	eor	r25, r25
 fa2:	80 b5       	in	r24, 0x20	; 32
 fa4:	08 95       	ret

00000fa6 <__eerd_word_m48>:
 fa6:	a8 e1       	ldi	r26, 0x18	; 24
 fa8:	b0 e0       	ldi	r27, 0x00	; 0
 faa:	42 e0       	ldi	r20, 0x02	; 2
 fac:	18 c0       	rjmp	.+48     	; 0xfde <__eerd_blraw_m48>

00000fae <__eeupd_byte_m48>:
 fae:	26 2f       	mov	r18, r22

00000fb0 <__eeupd_r18_m48>:
 fb0:	f9 99       	sbic	0x1f, 1	; 31
 fb2:	fe cf       	rjmp	.-4      	; 0xfb0 <__eeupd_r18_m48>
 fb4:	12 bc       	out	0x22, r1	; 34
 fb6:	81 bd       	out	0x21, r24	; 33
 fb8:	f8 9a       	sbi	0x1f, 0	; 31
 fba:	81 50       	subi	r24, 0x01	; 1
 fbc:	00 b4       	in	r0, 0x20	; 32
 fbe:	02 16       	cp	r0, r18
 fc0:	39 f0       	breq	.+14     	; 0xfd0 <__eeupd_r18_m48+0x20>
 fc2:	1f ba       	out	0x1f, r1	; 31
 fc4:	20 bd       	out	0x20, r18	; 32
 fc6:	0f b6       	in	r0, 0x3f	; 63
 fc8:	f8 94       	cli
 fca:	fa 9a       	sbi	0x1f, 2	; 31
 fcc:	f9 9a       	sbi	0x1f, 1	; 31
 fce:	0f be       	out	0x3f, r0	; 63
 fd0:	08 95       	ret

00000fd2 <__eeupd_word_m48>:
 fd2:	01 96       	adiw	r24, 0x01	; 1
 fd4:	27 2f       	mov	r18, r23
 fd6:	ec df       	rcall	.-40     	; 0xfb0 <__eeupd_r18_m48>
 fd8:	ea cf       	rjmp	.-44     	; 0xfae <__eeupd_byte_m48>

00000fda <__eerd_block_m48>:
 fda:	dc 01       	movw	r26, r24
 fdc:	86 2f       	mov	r24, r22

00000fde <__eerd_blraw_m48>:
 fde:	e8 2f       	mov	r30, r24
 fe0:	f9 99       	sbic	0x1f, 1	; 31
 fe2:	fe cf       	rjmp	.-4      	; 0xfe0 <__eerd_blraw_m48+0x2>
 fe4:	12 bc       	out	0x22, r1	; 34
 fe6:	05 c0       	rjmp	.+10     	; 0xff2 <__eerd_blraw_m48+0x14>
 fe8:	e1 bd       	out	0x21, r30	; 33
 fea:	f8 9a       	sbi	0x1f, 0	; 31
 fec:	e3 95       	inc	r30
 fee:	00 b4       	in	r0, 0x20	; 32
 ff0:	0d 92       	st	X+, r0
 ff2:	41 50       	subi	r20, 0x01	; 1
 ff4:	c8 f7       	brcc	.-14     	; 0xfe8 <__eerd_blraw_m48+0xa>
 ff6:	08 95       	ret

00000ff8 <_exit>:
 ff8:	f8 94       	cli

00000ffa <__stop_program>:
 ffa:	ff cf       	rjmp	.-2      	; 0xffa <__stop_program>
